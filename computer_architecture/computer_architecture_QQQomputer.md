## 1. 컴퓨터 구조의 큰 그림

### 컴퓨터 구조의 의미

- **컴퓨터 구조**: 컴퓨터 과학의 가장 근원적인 학문, 하드웨어에 가장 가까운 학문
- **중요성**: 모든 컴퓨터 과학 개념의 기저에는 그 개념을 실행하는 하드웨어 부품이 있음
- 컴퓨터 구조에 대한 이해는 컴퓨터 과학을 이해하기 위한 시작점

### 컴퓨터가 이해하는 정보

1. **데이터**: 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
    - 데이터는 있는 그대로의 정보
    - 컴퓨터와 주고받는 정보나 저장된 정보 자체를 의미
2. **명령어**: 데이터를 활용하는 정보
    - 데이터는 명령어에 종속적인 정보
    - 명령의 대상이자 재료
    - 컴퓨터는 기본적으로 0과 1만 이해할 수 있어 데이터와 명령어 또한 0과 1로 이루어짐

### 컴퓨터의 핵심 부품

1. **CPU(중앙처리장치, Central Processing Unit)**
    - 데이터와 명령어를 읽어 들이고, 해석하고, 실행
    - 사람으로 비유하면 두뇌에 해당하는 부품
    - 주요 구성 요소: 산술논리연산장치(ALU), 제어장치, 레지스터
2. **메모리(주기억장치)**
    - 현재 실행 중인 프로그램을 구성하는 데이터와 명령어를 저장
    - RAM(Random Access Memory)이 주로 사용됨
    - 휘발성 저장장치: 전원이 꺼지면 저장된 정보가 사라짐
3. **캐시 메모리**
    - CPU와 메모리 사이에 위치
    - CPU가 빠르게 메모리에 저장된 값에 접근하기 위한 저장장치
    - 여러 종류가 있음(L1, L2, L3)
4. **보조기억장치**
    - 비휘발성 저장장치: 전원이 꺼져도 저장된 정보가 사라지지 않음
    - 종류: CD-ROM, DVD, 하드 디스크 드라이브(HDD), 플래시 메모리(SSD, USB)
    - 보관할 프로그램을 저장
5. **입출력장치**
    - 컴퓨터 외부에 연결되어 내부와 정보를 교환하는 장치
    - 입력장치: 마우스, 키보드, 마이크 등
    - 출력장치: 스피커, 모니터, 프린터 등

### 메인 보드와 버스

- **메인 보드(마더보드)**: 컴퓨터의 핵심 부품들을 고정하고 연결하는 기판
- **버스**: 컴퓨터 부품들이 정보를 주고받는 통로
    - **시스템 버스**: 핵심 부품들을 연결하는 중요한 버스(몸을 지탱하는 척추와 같음)

### 저장장치의 계층 구조

- **계층 순서**(CPU와의 거리 기준): 레지스터 → 캐시 메모리 → 메모리 → 보조기억장치
- **특성 비교**:
    - **속도**: 빠름 → 느림
    - **용량**: 작음 → 큼
    - **가격**: 비쌈 → 저렴함
- 각각의 상반된 특성으로 인해 계층별 저장장치를 모두 함께 사용하는 것이 일반적

### 컴퓨터 구조 지도

컴퓨터 구조 학습 내용은 크게 다음과 같이 구성됨:

1. 컴퓨터 구조의 큰 그림
2. 컴퓨터가 이해하는 정보(데이터, 명령어)
3. 컴퓨터의 핵심 부품(CPU, 메모리, 보조기억장치, 입출력장치)

## 2. 컴퓨터가 이해하는 정보

### 비트와 바이트

- **비트(bit)**: 0 또는 1을 나타내는 가장 작은 정보 단위
- **바이트(byte)**: 8비트, 2^8 = 256개의 정보 표현 가능
- **정보 단위**:
    - 1 byte = 8 비트
    - 1 KB = 1,000 바이트
    - 1 MB = 1,000 킬로바이트
    - 1 GB = 1,000 메가바이트
    - 1 TB = 1,000 기가바이트
    - (참고: 1 KiB = 1,024 바이트, 1 MiB = 1,024 KiB 등으로 표현하기도 함)
- **워드(word)**: CPU가 한 번에 처리할 수 있는 데이터 크기
    - 현대 컴퓨터의 워드 크기는 보통 32비트 또는 64비트

### 데이터 - 0과 1로 숫자 표현하기

### 2진법과 16진법

- **2진법(binary)**: 0과 1만을 사용하여 수를 표현
    - 2진수로 표현된 수는 숫자 뒤에 아래첨자로 (2)를 붙이거나 앞에 0b를 붙임
    - 예: 0b1010 = 10(10)
- **16진법(hexadecimal)**: 0-9, A-F까지 16개 문자를 사용하여 수를 표현
    - 16진수로 표현된 수는 숫자 뒤에 아래첨자로 (16)을 붙이거나 앞에 0x를 붙임
    - 예: 0x1A = 26(10)
    - 16진수는 2진수 표현을 간략화하는데 유용(4비트를 한 자리로 표현)
    - MAC 주소, IPv6 주소 등에 사용

### 부동 소수점

- **부동 소수점(floating point)**: 소수점이 고정되지 않은 실수 표현 방식
- **IEEE 754 표준**: 2진수의 지수와 가수를 다음과 같은 형식으로 저장
- **소수 표현의 한계**: 일부 10진 소수(예: 0.1, 0.2)는 2진 부동소수점으로 정확히 표현 불가능
    - 이로 인해 `0.1 + 0.2 == 0.3`이 false가 되는 현상 발생
    - 예시 코드 실행 결과:
    
    ```python
    a = 0.1
    b = 0.2
    c = 0.3
    if a + b == c:
        print("Equal")
    else:
        print("Not Equal")  # 실제 출력: "Not Equal"
    ```
    

### 데이터 - 0과 1로 문자 표현하기

### 문자 집합과 인코딩

- **문자 집합(character set)**: 컴퓨터가 이해할 수 있는 문자들의 집합
- **문자 인코딩(character encoding)**: 문자를 0과 1로 변환하는 과정
- **문자 디코딩(character decoding)**: 0과 1로 표현된 문자를 다시 사람이 이해하는 문자로 변환하는 과정

### 아스키 코드(ASCII)

- 초창기 컴퓨터에서 사용하던 문자 집합
- 영어 알파벳, 아라비아 숫자, 일부 특수 문자 포함
- 7비트(128개 문자) 사용, 8비트 중 1비트는 패리티 비트(오류 검출용)
- 예: 'A'는 10진수 65(2진수 1000001)로 인코딩

### EUC-KR

- 한글을 표현하기 위한 인코딩 방식
- 아스키 문자는 1바이트, 한글은 2바이트 크기의 코드 부여
- 약 2,350개의 한글 단어 표현 가능
- 예: '한'은 0xc7d1로 인코딩, '글'은 0xb1db로 인코딩

```python
a = '한'.encode('euc-kr')
b = '글'.encode('euc-kr')
print(a.hex())  # 출력: c7d1
print(b.hex())  # 출력: b1db
```

### 유니코드(Unicode)

- 전 세계 모든 문자를 표현할 수 있는 통일된 문자 집합
- 한글, 중국어, 일본어 등 다양한 언어와 특수문자, 이모티콘 모두 표현 가능
- 각 문자에 고유한 코드 포인트(code point) 부여
- 예: '한'의 코드 포인트는 0xD55C, '글'은 0xAE00

```python
a = hex(ord('한'))
b = hex(ord('글'))
print(a)  # 출력: 0xd55c
print(b)  # 출력: 0xae00
```

### UTF 인코딩(UTF-8, UTF-16, UTF-32)

- 유니코드 문자에 부여된 값을 인코딩하는 방식
- 가변 길이 인코딩 방식: 인코딩된 결과의 길이가 일정하지 않음
- **UTF-8**: 웹에서 가장 많이 사용되는 인코딩 방식
- **UTF-16**: 윈도우 내부에서 많이 사용하는 인코딩 방식
- **UTF-32**: 모든 문자를 4바이트로 표현하는 방식

```python
a8 = '한'.encode('utf-8')
b8 = '글'.encode('utf-8')
print("utf-8 한:", a8.hex())  # 출력: ed959c
print("utf-8 글:", b8.hex())  # 출력: eab880

a16 = '한'.encode('utf-16')
b16 = '글'.encode('utf-16')
print("utf-16 한:", a16.hex())  # 출력: fffe5cd5
print("utf-16 글:", b16.hex())  # 출력: fffe00ae

a32 = '한'.encode('utf-32')
b32 = '글'.encode('utf-32')
print("utf-32 한:", a32.hex())  # 출력: fffe00005cd50000
print("utf-32 글:", a32.hex())  # 출력: fffe000000ae0000
```

### Base64 인코딩

- 바이너리 데이터를 아스키 문자 형태로 표현하는 인코딩 방식
- 주로 이미지 등 바이너리 데이터를 텍스트로 전송할 때 사용(이메일 첨부파일 등)
- 6비트를 하나의 문자로 변환(2^6 = 64개의 문자 사용)
- 변환 과정 예시:
    - 'abc'를 ASCII 코드로 변환: 97, 98, 99
    - 2진수로 변환: 01100001 01100010 01100011
    - 6비트씩 분할: 011000 010110 001001 100011
    - Base64 테이블에 따라 변환: YWJj

### 명령어

- **명령어 구성**: 연산 코드(수행할 동작) + 오퍼랜드(수행할 대상)
    
    ```
    수행할 동작     수행할 대상
    +---------+---------------------+
    |  더해라  | 100과 메모리 32번지 |
    +---------+---------------------+
    ```
    
- **연산 코드(operation code)**: 명령어가 수행할 동작
- **오퍼랜드(operand)**: 동작에 사용될 데이터 또는 데이터가 저장된 위치
    - 오퍼랜드 필드는 주소 필드(address field)라고도 부름
- **명령어 종류**:
    - **데이터 전송**: MOVE, STORE, LOAD(FETCH), PUSH, POP
    - **산술/논리 연산**: ADD, SUB, MUL, DIV, AND, OR, NOT
    - **제어 흐름 변경**: JUMP, CONDITIONAL JUMP
    - **입출력 제어**: IN, OUT

### 기계어와 어셈블리어

- **기계어(machine code)**: CPU가 이해할 수 있는 0과 1로 표현된 명령어
- **어셈블리어(assembly language)**: 기계어를 읽기 편한 형태로 단순 번역한 언어
    
    ```
    기계어             어셈블리어0101 0101  →     push rbp0101 1101  →     pop rbp1100 0011  →     ret
    ```
    
- CPU마다 이해하는 명령어가 다르기 때문에 같은 프로그램이라도 CPU에 따라 다른 기계어로 변환됨
    - **CISC 기반 CPU** (복잡한 명령어 집합): 인텔 x86, x86-64
    - **RISC 기반 CPU** (간소화된 명령어 집합): ARM, 애플 M1

### 명령어 사이클

- **인출 사이클(fetch cycle)**: 메모리에서 명령어를 CPU로 가져오는 단계
- **간접 사이클(indirect cycle)**: 명령어 실행을 위해 추가로 메모리에 접근하는 단계
- **실행 사이클(execution cycle)**: CPU로 가져온 명령어를 실행하는 단계
- **인터럽트 사이클(interrupt cycle)**: 인터럽트를 처리하는 단계

## 3. CPU

### 레지스터

- **레지스터**: CPU 안에 있는 작은 임시 저장장치
    - 데이터와 명령어, 주소 등을 저장
    - 프로그램 실행 과정에서 중간값을 저장
- **주요 레지스터**:
    1. **프로그램 카운터(Program Counter, PC)**
        - 다음으로 읽어 들일 명령어의 주소를 저장
        - 명령어 포인터(Instruction Pointer, IP)라고도 함
        - 일반적으로 1씩 증가하며 순차적 실행 가능
        - 조건문, 리턴문 등으로 프로그램 흐름이 변경될 때 임의의 값으로 변경됨
    2. **명령어 레지스터(Instruction Register, IR)**
        - 해석할 명령어, 즉 메모리에서 읽어 들인 명령어를 저장
        - 제어장치가 이를 해석해 ALU나 다른 부품에 제어 신호 전달
    3. **범용 레지스터(General Purpose Register)**
        - 다양한 상황에서 자유롭게 사용할 수 있는 레지스터
        - 데이터, 명령어, 주소 등 모두 저장 가능
        - CPU 내에 여러 개 존재
    4. **플래그 레지스터(Flag Register)**
        - 연산 결과나 CPU 상태에 대한 부가 정보(플래그) 저장
        - 주요 플래그:
            - **부호 플래그**: 연산 결과가 음수(1)인지 양수(0)인지 표시
            - **제로 플래그**: 연산 결과가 0(1)인지 아닌지(0) 표시
            - **캐리 플래그**: 연산 결과에 올림수나 빌림수 발생 여부 표시
            - **오버플로우 플래그**: 오버플로우 발생 여부 표시
            - **인터럽트 플래그**: 인터럽트 가능 여부 표시
            - **슈퍼바이저 플래그**: 커널 모드(1)인지 사용자 모드(0)인지 표시
    5. **스택 포인터(Stack Pointer)**
        - 메모리 내 스택 영역의 최상단 데이터 위치를 가리키는 레지스터
        - 스택에 데이터를 저장하거나 꺼낼 때 참조됨

### 인터럽트

- **인터럽트(interrupt)**: CPU가 수행 중인 작업을 방해하는 신호
- **인터럽트 종류**:
    1. **동기 인터럽트(예외, Exception)**
        - CPU에 의해 발생하는 인터럽트
        - 프로그래밍 오류와 같은 예상치 못한 상황에서 발생
    2. **비동기 인터럽트(하드웨어 인터럽트)**
        - 주로 입출력장치에 의해 발생하는 인터럽트
        - 입출력 작업 완료 알림이나 입력 알림의 역할
- **인터럽트 처리 과정**:
    1. 입출력장치가 CPU에게 인터럽트 요청 신호를 보냄
    2. CPU는 실행 사이클이 끝나고 인터럽트 여부 확인
    3. 인터럽트 플래그를 통해 인터럽트 수용 가능 여부 확인
    4. 현재 작업 상태를 백업(프로그램 카운터 등을 스택에 저장)
    5. 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
    6. 인터럽트 서비스 루틴 실행 후 백업해둔 작업 복구
- **인터럽트 관련 중요 개념**:
    - **인터럽트 요청 신호**: 인터럽트의 가능 여부를 확인하는 신호
    - **인터럽트 플래그**: 하드웨어 인터럽트를 받아들일지 결정하는 플래그
    - **마스크 가능 인터럽트(maskable interrupt)**: 인터럽트 플래그로 막을 수 있는 인터럽트
    - **마스크 불가능 인터럽트(non-maskable interrupt)**: 인터럽트 플래그로 막을 수 없는 인터럽트
    - **인터럽트 벡터(interrupt vector)**: 인터럽트 서비스 루틴을 식별하기 위한 정보
    - **인터럽트 서비스 루틴(interrupt service routine)**: 인터럽트를 처리하기 위한 프로그램
    - **인터럽트 핸들러(interrupt handler)**: 인터럽트 서비스 루틴의 다른 이름
- **다중 인터럽트 처리**:
    - 여러 장치로부터 동시에 인터럽트가 발생할 경우 우선순위에 따라 처리
    - **PIC(Programmable Interrupt Controller)**: 인터럽트 우선순위를 판별하는 장치
    - 높은 우선순위의 인터럽트는 현재 처리 중인 인터럽트를 일시 중단시킬 수 있음

### 예외(동기 인터럽트)

- **폴트(fault)**: 예외 처리 후 예외가 발생한 명령어부터 실행 재개
    - 예: 페이지 폴트(필요한 데이터가 메모리에 없을 때 발생)
- **트랩(trap)**: 예외 처리 후 예외가 발생한 명령어의 다음 명령어부터 실행 재개
    - 예: 디버깅의 브레이크 포인트
- **중단(abort)**: 심각한 오류로 프로그램을 강제 중단
- **소프트웨어 인터럽트**: 시스템 콜이 발생했을 때 발생하는 예외

### CPU 성능 향상을 위한 설계

### CPU 클럭 속도

- **클럭**: 컴퓨터 부품을 규칙적으로 움직이게 하는 시간 단위
- **클럭 속도**: 초당 클럭이 반복되는 횟수, 헤르츠(Hz) 단위로 측정
- 클럭 속도가 높을수록 CPU 성능이 좋아지나, 발열 증가로 한계 존재

### 멀티코어와 멀티스레드

- **코어(core)**: CPU 내에서 명령어를 읽고, 해석하고, 실행하는 부품
- **멀티코어 CPU**: 여러 개의 코어를 포함하는 CPU
    - 듀얼 코어(2개), 쿼드 코어(4개), 옥타 코어(8개) 등
- **하드웨어 스레드**: 하나의 코어가 동시에 처리하는 명령어의 단위
- **멀티스레드 CPU**: 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- **논리 프로세서(logical processor)**: 메모리 입장에서 본 하드웨어 스레드
- **소프트웨어 스레드**: 하나의 프로그램에서 독립적으로 실행되는 단위
    - 단일 코어에서도 소프트웨어 스레드를 통한 멀티스레딩 가능
    
    ```python
    import threading
    import time
    
    def task1():
        for i in range(5):
            print("Task 1 is running")
            time.sleep(1)
    
    def task2():
        for i in range(5):
            print("Task 2 is running")
            time.sleep(1)
    
    thread1 = threading.Thread(target=task1)
    thread2 = threading.Thread(target=task2)
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
    
    print("All tasks are done.")
    ```
    

### 동시성과 병렬성

- **병렬성(parallelism)**: 작업을 물리적으로 동시에 처리하는 성질
    - 예: 멀티코어 CPU에서 각 코어가 동시에 명령어 처리
- **동시성(concurrency)**: 동시에 작업을 처리하는 것처럼 보이는 성질
    - 예: 싱글 코어에서 작업을 빠르게 전환하며 처리

### 명령어 파이프라이닝

- **명령어 파이프라이닝(instruction pipelining)**: 명령어 처리 과정을 여러 단계로 나누어 여러 명령어를 겹쳐서 실행하는 기법
- **명령어 처리 단계**:
    1. 명령어 인출(Instruction Fetch)
    2. 명령어 해석(Instruction Decode)
    3. 명령어 실행(Execute Instruction)
    4. 결과 저장(Write Back)
- **슈퍼스칼라(superscalar)**: CPU 내부에 여러 개의 파이프라인을 포함하는 구조
    - 공장의 생산 라인을 여러 개 두는 것과 유사
- **CISC vs RISC**:
    - **CISC(Complex Instruction Set Computer)**: 복잡한 명령어들로 구성된 명령어 집합
        - 적은 수의 명령어로 프로그램 실행 가능
        - 명령어 크기와 실행 시간이 일정하지 않아 파이프라이닝에 비효율적
        - 예: 인텔 x86, x86-64
    - **RISC(Reduced Instruction Set Computer)**: 간소화된 명령어 집합
        - 짧고 규격화된 명령어, 1클럭 내외로 실행됨
        - 같은 프로그램에 더 많은 명령어 필요
        - 파이프라이닝에 최적화
        - 예: ARM, 애플 M1

### 파이프라인 위험

- **데이터 위험(data hazard)**: 명령어 간의 데이터 의존성에 의해 발생
    
    ```
    명령어 1: R1 <- R2 + R3명령어 2: R4 <- R1 + R5  // R1에 의존성 있음
    ```
    
- **제어 위험(control hazard)**: 프로그램 카운터의 갑작스러운 변화에 의해 발생
    - JUMP, CONDITIONAL JUMP, 인터럽트 등으로 발생
- **구조적 위험(structural hazard)**: 서로 다른 명령어가 동시에 같은 CPU 부품을 사용하려 할 때 발생
    - 자원 위험(resource hazard)이라고도 함

## 4. 메모리

### RAM

- **RAM(Random Access Memory, 임의 접근 메모리)**: 저장된 요소에 순차적으로 접근할 필요 없이 임의 위치에 곧장 접근 가능
- **직접 접근(direct access)**: 어떤 위치에 접근하든 동일한 시간 소요
- **순차 접근(sequential access)**: 특정 위치에 접근하기 위해 처음부터 순차적으로 접근

### RAM 종류

1. **DRAM(Dynamic RAM)**
    - 시간이 지나면 저장된 데이터가 사라지는 RAM
    - 일정 주기로 데이터를 재활성화(다시 저장)해야 함
    - 소비 전력이 낮고, 저렴하며, 집적도가 높아 대용량 메모리로 적합
    - 일반적인 주기억장치로 사용됨
2. **SRAM(Static RAM)**
    - 시간이 지나도 저장된 데이터가 사라지지 않는 RAM
    - 전원이 공급되지 않으면 여전히 소실됨(휘발성)
    - DRAM보다 속도 빠르지만, 소비 전력 크고 가격 비쌈, 집적도 낮음
    - 캐시 메모리 등에 사용
3. **SDRAM(Synchronous DRAM)**
    - 클럭 신호와 동기화된 DRAM
    - 클럭 타이밍에 맞춰 CPU와 정보 주고받음
4. **DDR SDRAM(Double Data Rate SDRAM)**
    - 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
    - 한 클럭당 두 번씩 CPU와 데이터 주고받음
    - DDR2는 DDR보다 2배, DDR3는 DDR2보다 2배, DDR4는 DDR3보다 2배 빠름
    - 최근에는 DDR4 SDRAM이 많이 사용됨

### 메모리에 바이트를 저장하는 순서

- 메모리는 일반적으로 데이터를 워드(4바이트 또는 8바이트) 단위로 받아들임
- 여러 바이트로 구성된 데이터는 여러 주소에 저장됨

### 빅 엔디안과 리틀 엔디안

- **빅 엔디안(Big-endian)**: 낮은 번지의 주소에 상위 바이트부터 저장
    - 예: 16진수 1A2B3C4D를 a+2번지부터 저장 → a+2:1A, a+3:2B, a+4:3C, a+5:4D
    - 장점: 사람이 읽고 쓰는 순서와 동일해 디버깅 편리
- **리틀 엔디안(Little-endian)**: 낮은 번지의 주소에 하위 바이트부터 저장
    - 예: 16진수 1A2B3C4D를 a+2번지부터 저장 → a+2:4D, a+3:3C, a+4:2B, a+5:1A
    - 장점: 수치 계산에 편리(작은 자릿수부터 계산 가능)
- **MSB(Most Significant Bit)**: 숫자의 크기에 가장 큰 영향을 미치는 비트
- **LSB(Least Significant Bit)**: 숫자의 크기에 가장 작은 영향을 미치는 비트
- 실제 코드를 통한 확인 예:

```python
import sys
print(sys.byteorder)  # 'little' 또는 'big' 출력

import struct
print(struct.pack('>f', 107.6640625).hex())  # 빅 엔디안: '42d75400'
print(struct.pack('<f', 107.6640625).hex())  # 리틀 엔디안: '0054d742'
```

### 캐시 메모리

- **캐시 메모리(cache memory)**: CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위한 저장장치
- CPU와 메모리 사이에 위치한 SRAM 기반 저장장치
- 메모리에서 CPU가 사용할 데이터를 미리 가져와 저장

### 캐시 메모리 계층

- **L1 캐시**: 코어와 가장 가까운 캐시, 가장 빠름
    - **L1I 캐시**: 명령어만 저장하는 L1 캐시
    - **L1D 캐시**: 데이터만 저장하는 L1 캐시
- **L2 캐시**: L1 다음으로 가까운 캐시
- **L3 캐시**: 코어 외부에 위치, 여러 코어가 공유
- 속도: L1 > L2 > L3, 용량: L1 < L2 < L3

### 캐시 히트와 캐시 미스

- **캐시 히트(cache hit)**: 캐시 메모리가 예측하여 저장한 데이터가 CPU에 의해 실제로 사용되는 경우
- **캐시 미스(cache miss)**: 캐시 메모리에 CPU가 필요로 하는 데이터가 없어 메모리에서 직접 가져와야 하는 경우
- **캐시 적중률(cache hit rate)**: 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
    - 일반적인 컴퓨터의 캐시 적중률은 약 85~95%

### 참조 지역성의 원리

- 캐시 메모리는 참조 지역성의 원리(principle of locality)에 따라 메모리로부터 가져올 데이터를 결정
- **시간 지역성(temporal locality)**: CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향
    - 예: 변수 값은 프로그램 실행 중 여러 번 사용됨
- **공간 지역성(spatial locality)**: CPU는 접근한 메모리 공간의 근처에 접근하려는 경향
    - 예: 배열의 요소들은 메모리에 연속적으로 저장됨

```python
# 공간 지역성을 고려한 코드 (좋은 예)
matrix = [[0] * 20000 for _ in range(20000)]
for i in range(20000):
    for j in range(20000):
        matrix[i][j] = 1  # 메모리에 순차적으로 접근

# 공간 지역성을 고려하지 않은 코드 (나쁜 예)
matrix = [[0] * 20000 for _ in range(20000)]
for i in range(20000):
    for j in range(20000):
        matrix[j][i] = 1  # 메모리에 비순차적으로 접근
```

### 캐시 메모리의 쓰기 정책

- **즉시 쓰기(write-through)**: 캐시 메모리와 메모리에 동시에 쓰는 방식
    - 장점: 메모리가 항상 최신 상태 유지, 일관성 유지
    - 단점: 메모리 접근 횟수 증가로 속도 저하
- **지연 쓰기(write-back)**: 캐시 메모리에만 값을 써두었다가 추후 메모리에 반영하는 방식
    - 장점: 메모리 접근 횟수 감소로 속도 향상
    - 단점: 캐시-메모리 간 일관성 깨질 수 있음

### 캐시 일관성 문제

- **캐시 일관성(cache coherence)**: 여러 캐시 간에 동일한 메모리 위치의 데이터가 일치하도록 유지하는 문제
- **캐시 일관성 프로토콜**: 여러 코어/CPU의 캐시 간 일관성을 유지하기 위한 프로토콜

## 5. 보조기억장치와 입출력장치

### 보조기억장치

- **보조기억장치**: 전원이 꺼져도 저장된 정보가 사라지지 않는 비휘발성 저장장치
- **종류**:
    1. **하드 디스크 드라이브(HDD)**: 자기적 방식으로 데이터를 읽고 쓰는 보조기억장치
        - 플래터(원판)와 헤드로 구성
    2. **플래시 메모리 기반 저장장치**: 전기적 방식으로 데이터를 읽고 쓰는 저장장치
        - SSD, USB 메모리, SD 카드 등
- **역할**:
    - 데이터를 안전하게 보관
    - 필요한 정보를 메모리에 전달

### RAID

- **RAID(Redundant Array of Independent Disks)**: 데이터의 안전성/성능을 확보하기 위해 여러 개의 독립적인 보조기억장치를 하나처럼 사용하는 기술
- **RAID 레벨**:
    1. **RAID0**:
        - 데이터를 여러 디스크에 나누어 저장(스트라이핑)
        - 장점: 빠른 입출력 속도(이론상 디스크 수만큼 빨라짐)
        - 단점: 하나의 디스크에 문제가 생기면 전체 데이터 손실
    2. **RAID1**:
        - 완전한 복사본을 만들어 저장(미러링)
        - 장점: 복구가 간단하고 안전성 높음
        - 단점: 쓰기 속도가 느리고, 저장 용량이 절반으로 줄어듦
    3. **RAID4**:
        - 패리티 정보를 저장하는 디스크를 따로 두는 구성
        - 패리티: 오류를 검출할 수 있는 정보
        - 단점: 패리티 디스크에 병목 현상 발생
    4. **RAID5**:
        - 패리티를 분산하여 저장하는 구성
        - RAID4의 병목 현상 해결
    5. **RAID6**:
        - 서로 다른 2개의 패리티를 두는 구성
        - 장점: 안전성 매우 높음
        - 단점: 쓰기 속도가 느림
    6. **Nested RAID**:
        - 여러 RAID 레벨을 혼합한 방식
        - 예: RAID10(RAID1+RAID0), RAID50(RAID5+RAID0)

### 입출력 기법

### 장치 컨트롤러와 장치 드라이버

- **장치 컨트롤러(device controller)**: CPU와 입출력장치 사이의 통신을 중개하는 하드웨어
    - 각 입출력장치마다 고유한 장치 컨트롤러 존재
    - 내부에 RAM과 같은 저장장치 포함
- **장치 드라이버(device driver)**: 장치 컨트롤러의 동작을 알고, 컨트롤러가 컴퓨터 내부와 정보를 주고받도록 하는 프로그램
    - 운영체제에 기본 포함되거나 별도 설치

### 입출력 기법 종류

1. **프로그램 입출력(programmed I/O)**:
    - 프로그램 속 명령어로 입출력 작업을 직접 수행
    - CPU가 입출력 작업을 처음부터 끝까지 직접 관리
    - 두 종류:
        - **고립형 입출력(isolated I/O)**: 입출력장치와 메모리의 주소 공간 분리
        - **메모리 맵 입출력(memory mapped I/O)**: 입출력장치에 메모리 주소 할당
2. **인터럽트 기반 입출력(interrupt-driven I/O)**:
    - 입출력장치가 작업 완료 시 CPU에 인터럽트 발생
    - CPU는 다른 작업 수행 가능하여 효율적
    - **다중 인터럽트 처리**:
        - PIC(Programmable Interrupt Controller): 여러 장치의 인터럽트 우선순위 관리
        - 계층 구조로 다수의 입출력장치 인터럽트 처리
3. **DMA 입출력(Direct Memory Access I/O)**:
    - CPU를 거치지 않고 입출력장치와 메모리가 직접 상호작용
    - **DMA 컨트롤러**: CPU 대신 입출력 작업 수행
    - **DMA 입출력 과정**:
        1. CPU가 DMA 컨트롤러에 입출력 작업 명령
        2. DMA 컨트롤러가 장치 컨트롤러와 상호작용하며 작업 수행(메모리 직접 접근)
        3. 작업 완료 시 CPU에 인터럽트 발생
    - **사이클 스틸링(cycle stealing)**: DMA 컨트롤러가 CPU가 시스템 버스를 사용하지 않을 때 시스템 버스 사용

### PCIe

- **PCIe(Peripheral Component Interconnect Express)**: 대표적인 입출력 버스
- **특징**:
    - 여러 버전 존재(PCIe 3.0, 4.0, 5.0 등)
    - 버전에 따라 최대 속도 다름
    - **레인(lane)**: PCIe 버스를 통해 정보를 송수신하는 단위
        - x1, x4, x8, x16 등으로 표기
        - 레인 수에 따라 대역폭 증가
    - SSD, GPU, 네트워크 인터페이스 카드 등 다양한 장치 연결

### GPU

- **GPU(Graphics Processing Unit)**: 그래픽 처리 장치, 대량의 그래픽 연산을 위해 탄생
- **GPGPU(General-Purpose computing on GPU)**: 그래픽 외 범용적인 목적의 GPU 사용 기술
    - 딥러닝, 가상화폐 채굴 등에 활용

### GPU 특징

- **코어 수**: 수백~수천 개의 코어 포함
- **코어 성능**: 개별 코어 성능은 CPU보다 낮음
- **병렬 처리**: 단순 연산을 병렬적으로 수행하는 데 최적화
- **캐시 및 메모리**: 자체 캐시와 대용량 메모리 포함
- **보조 프로세서**: CPU의 산술 연산을 보조하는 역할

### GPU vs CPU

- **GPU**: 단순 연산을 병렬적으로 빠르게 수행(SIMD 방식)
- **CPU**: 복잡한 연산과 범용적인 작업 수행
- GPU는 CPU를 완전히 대체할 수 없음
    - 운영체제 실행이나 복잡한 명령어 처리 불가

### CUDA

- **CUDA**: 엔비디아가 개발한, GPU 프로그래밍을 위한 플랫폼
- **구성**:
    - **호스트 코드(host code)**: CPU가 실행할 코드
    - **디바이스 코드(device code)**: GPU가 실행할 코드

```c
#include <stdio.h>

__global__ void cuda_hello() {
    printf("Hello World from GPU!\n");
}

int main() {
    cuda_hello<<<1,1>>>();
    cudaDeviceSynchronize();
    return 0;
}
```

## 6. 기술 면접 질문과 답변

### Q1. RAM과 하드 디스크의 차이를 설명해 보세요.

**A1.** RAM이 CPU가 실행할 프로그램을 저장하는 부품이라면, 하드 디스크는 전원이 꺼져도 보관할 대상을 저장하는 부품입니다. 휘발성 저장장치인 RAM은 전원이 꺼지면 저장된 내용을 잃지만, 하드 디스크는 비휘발성 저장장치이기 때문에 전원이 꺼져도 저장된 내용을 잃지 않는다는 차이가 있습니다.

### Q2. 병렬성과 동시성, 두 개념의 차이를 예시와 함께 설명해 보세요.

**A2.** 병렬성은 작업을 실제로 같은 시각에 동시 처리하는 성질을 의미하고, 동시성은 작업을 동시에 처리하는 것처럼 보이는 성질을 의미합니다. 멀티코어 CPU의 여러 코어가 같은 시각에 명령어를 동시에 처리하는 것이 병렬성의 예시이고, 1코어 1스레드 CPU가 여러 작업을 빠르게 번갈아 가며 처리하는 것이 동시성의 예시입니다.

### Q3. CPU가 자발적으로 발생시키는 인터럽트와 CPU가 받아들이는 인터럽트의 차이가 무엇인지 설명해 보세요.

**A3.** CPU가 자발적으로 발생시키는 인터럽트는 동기적인 인터럽트로, CPU가 프로그래밍 오류와 같은 예외적으로 예상치 못한 상황을 마주쳤을 때 주로 발생하는 인터럽트입니다. 반면, CPU가 받아들이는 인터럽트는 비동기적인 인터럽트로, 주로 입출력장치로부터 받아들이는 하드웨어 인터럽트를 말합니다.

### Q4. 다음 소스 코드의 결과는 모두 '0.30000000000000004'입니다. 그 이유를 설명해 보세요.

```python
print(0.1 + 0.2)
```

```java
System.out.println(0.1 + 0.2);
```

```jsx
console.log(0.1 + 0.2);
```

**A4.** 컴퓨터는 내부적으로 부동 소수점 방식을 통해 소수를 표현합니다. 부동 소수점 방식은 2진수로 소수를 표현하는 방식으로, 가수×2^지수의 형태를 띕니다. 소스 코드에 지정된 '0.1'과 '0.2'는 10진수 소수로, 가수×10^지수의 형태로 표현할 수 있지만, 이를 부동 소수점 방식의 2진수로 표현하면 무한 소수가 됩니다. 무한 소수에 무한 소수를 더한 결과를 10진수 소수로 표현하다 보니 오차가 발생한 것입니다.

### Q5. 다음 소스 코드에는 성능상의 문제가 있습니다. 어떤 문제인지 설명해 보세요.

```java
public class Main {
    public static void main(String[] args) {
        int[][] matrix = new int[20000][20000];
        for (int i = 0; i < 20000; i++) {
            for (int j = 0; j < 20000; j++) {
                matrix[j][i] = 1;
            }
        }
    }
}

```

**A5.** 주어진 소스 코드 중 배열에 접근하는 `matrix[j][i] = 1;` 부분은 캐시 친화적이지 않기 때문에 성능상의 문제가 될 수 있습니다. 배열이 저장된 위치에 순차적으로 접근하지 않기 때문에 성능 저하를 가져오게 됩니다. 이차원 배열이 메모리에 저장된 순서에 따라 접근하도록 코드를 수정하면 프로그램의 속도를 개선할 수 있습니다.

### Q6. 장치 드라이버는 왜 설치해야 하나요?

**A6.** CPU가 장치 컨트롤러를 작동시키기 위한 정보를 알아야 하기 때문입니다. CPU는 장치 드라이버가 설치되어 있지 않으면 해당 입출력장치를 어떻게 작동시켜야 할지, 즉 장치 컨트롤러와 어떻게 정보를 주고받아야 하는지 알 수가 없습니다.

### Q7. 파이프라이닝이란 무엇이며, 어떻게 CPU의 성능을 향상시키는지 설명해 보세요.

**A7.** 파이프라이닝이란 명령어 병렬 처리 기법 중 하나로, 하나의 명령어를 처리하는 과정을 비슷한 시간 간격으로 쪼갠 뒤, 쪼개진 각각의 단계에서 동시에 실행 가능한 단계를 겹쳐서 실행해 CPU의 처리 성능을 높입니다. 마치 공장의 생산 라인처럼 여러 명령어를 동시에 다른 단계로 처리할 수 있게 하여 CPU의 유휴 시간을 줄이고 전체적인 처리량을 증가시킵니다.

### Q8. GPU와 CPU를 비교하여 설명해 보세요.

**A8.** GPU는 주로 산술 연산과 같이 단순 연산을 병렬적으로 수행하기 위한 장치이고, CPU는 범용적인 연산을 수행하기 위한 장치입니다. GPU는 병렬 처리를 위한 코어가 수백에서 수천 개까지 포함되어 있지만, CPU처럼 코어마다 복잡한 연산을 지원하지는 않습니다. GPU는 대용량 데이터를 병렬로 처리하는 데 최적화되어 있어 그래픽 처리, 딥러닝, 과학 계산 등에 적합하며, CPU는 복잡한 제어 흐름과 다양한 연산을 필요로 하는 일반적인 작업에 적합합니다.

### Q9. base64 인코딩이란 무엇이며, 어디에서 base64 인코딩을 사용하는지 설명해 보세요.

**A9.** base64 인코딩은 문자뿐만 아니라 아스키 코드로 표현할 수 없는 이미지 등의 이진 데이터까지 아스키 형태의 문자로 표현하기 위해 사용하는 인코딩 방식입니다. 주로 이메일에서 첨부파일을 전송하거나 웹에서 이미지 및 파일 데이터를 텍스트 형식으로 포함할 때 사용합니다. base64는 64개의 문자(A-Z, a-z, 0-9, +, /)를 사용하여 6비트씩 인코딩하며, 바이너리 데이터를 텍스트 기반 프로토콜로 안전하게 전송할 수 있게 합니다.

### Q10. 동일한 소스 코드라 하더라도 애플 M1 컴퓨터에서 컴파일해 만든 실행 파일을 인텔 X86 컴퓨터로 옮겨 실행할 수 없는 이유를 설명해 보세요.

**A10.** 동일한 소스 코드라도 각기 다른 명령어로 변환될 수 있기 때문입니다. 실행 파일은 각각의 컴퓨터가 이해할 수 있는 명령어의 모음이기 때문에 CPU마다 이해하는 명령어의 집합이 다릅니다. 따라서 실행할 수 있는 실행 파일도 달라집니다. 애플 M1 CPU는 ARM 기반 아키텍처를 사용하고, 인텔 X86 CPU는 x86 아키텍처를 사용하므로 서로 다른 명령어 집합을 가지고 있어 호환되지 않습니다. 이런 이유로 애플 M1 컴퓨터에서 컴파일해 만든 실행 파일을 인텔 X86 컴퓨터로 옮겨서 실행하면 실행이 되지 않는 것입니다.

### Q11. 하드웨어적 스레드와 소프트웨어적 스레드의 차이에 대해 설명해 보세요.

**A11.** 하드웨어 스레드는 하나의 코어가 동시에 처리하는 명령어의 단위를 의미합니다. 논리 프로세서라고도 부릅니다. 소프트웨어 스레드란 하나의 프로그램에서 독립적으로 실행되는 단위를 의미합니다. 따라서 1코어 1스레드 CPU에서도 여러 소프트웨어 스레드를 빠르게 번갈아 가며 실행할 수 있습니다. 하드웨어 스레드는 물리적인 병렬 처리를 위한 단위이고, 소프트웨어 스레드는 논리적인 동시성을 위한 단위라고 볼 수 있습니다.

### Q12. 코딩을 하다가 한글이 깨지면 어떻게 대처해야 할까요?

**A12.** 한글이 깨지는 경우는 컴퓨터가 이해할 수 있는 문자의 모음, 문자 집합을 인식하지 못했거나 문자 집합을 코드로 표현하는 인코딩 방법을 인식하지 못한 경우입니다. 따라서 다른 문자 집합을 지원하는 다양한 인코딩 방법을 시도해 봐야 합니다. 일반적으로 UTF-8, EUC-KR 등의 인코딩을 차례로 시도해보거나, 파일의 인코딩 설정을 명시적으로 변경해볼 수 있습니다. 또한 텍스트 에디터나 개발 환경에서 기본 인코딩 설정을 확인하고 필요에 따라 변경하는 것도 중요합니다.

### Q13. PCIe란 무엇이며, PCIe가 연결 부품의 성능과 어떤 연관이 있는지 설명해 보세요.

**A13.** PCIe(Peripheral Component Interconnect Express)란 대표적인 입출력 버스의 일종으로, 버전에 따라 지원되는 최대 속도(대역폭)이 달라져 연결되는 부품의 성능에 영향을 끼칠 수 있습니다. PCIe 3.0의 최대 지원 속도는 PCIe 6.0의 최대 지원 속도에 비해 느리기 때문에 같은 부품이라 하더라도 PCIe 3.0에 연결할 경우 입출력 버스의 최대 지원 속도가 더 느릴 수 있습니다. 또한 PCIe는 레인(lane)이라는 단위로 대역폭을 확장할 수 있어, x1, x4, x8, x16 등 레인 수에 따라 통신 속도가 달라집니다. 고성능 그래픽 카드는 보통 x16 레인을 사용하고, SSD는 x4 레인을 사용하는 경우가 많습니다.

### Q14. 캐시 미스란 무엇이며, 캐시 미스가 프로그램의 성능에 어떤 영향을 끼치는지 설명해 보세요.

**A14.** 캐시 미스란 캐시에 있을 것이라고 기대했던 데이터가 캐시에 존재하지 않는 상황을 의미합니다. 캐시 미스가 발생하면 캐시를 활용할 수 없고, 메모리와 같이 실제로 데이터가 위치하고 있는 먼 곳까지 접근해야 합니다. 따라서 프로그램의 성능에 악영향을 끼치게 됩니다. 캐시 메모리는 CPU와 메모리 사이의 속도 차이를 줄이기 위한 저장장치인데, 캐시 미스가 자주 발생하면 메모리에 직접 접근하는 횟수가 늘어나 처리 속도가 느려지게 됩니다. 따라서 캐시 미스를 최소화하는 것이 성능 향상에 중요하며, 이를 위해 공간 지역성과 시간 지역성을 고려한 프로그래밍이 필요합니다.

### Q15. 유니코드란 무엇인지 설명해 보세요.

**A15.** 유니코드는 여러 국가의 언어나 이모티콘 등을 표현할 수 있는 통일된 문자 집합을 말합니다. 유니코드는 전 세계 모든 문자를 표현할 수 있는 표준화된 코드 체계로, 각 문자마다 고유한 코드 포인트가 부여되어 있습니다. 이 코드 포인트를 어떻게 코드로 표현하는지에 따라 UTF-8, UTF-16, UTF-32 등 다양한 인코딩 방법으로 구분할 수 있습니다. 유니코드 이전에는 각 언어와 문자 체계마다 서로 다른 인코딩 방식을 사용했기 때문에 다국어 처리가 어려웠지만, 유니코드의 등장으로 단일 문서에서 다양한 언어를 혼합하여 사용할 수 있게 되었습니다.