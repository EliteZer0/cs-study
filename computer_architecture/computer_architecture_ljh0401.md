# 2장 컴퓨터 구조

## 1. 컴퓨터 구조의 큰 그림

이번 단원에서 배울 정보들을 미리 알아보자.

- 컴퓨터가 이해하는 정보

  크게 데이터, 명령어로 나뉜다.

  - 데이터
    - 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
    - 명령어에 종속적인 정보, 명령의 대상이자 명령어의 재료
  - 명령어
    - CPU가 이해하고 실행한다.
    - 명령어의 종류
    - 명령어 사이클

- 컴퓨터의 핵심 부품

  CPU(중앙처리장치), 메모리(주기억장치), 캐시 메모리, 보조기억장치, 입출력장치

  - CPU(Central Processing Unit)

    - 정보를 읽어 들이고, 해석하고, 실행하는 부품
    - 내부에는 산술논리연산장치(ALU)와 제어장치를 포함한 여러 레지스터가 존재.
      - 산술논리연산장치(ALU)
        - 사칙 연산, 논리 연산과 같은 연산을 수행할 회로로 구성된 계산기. 실질적으로 명령어를 연산하는 요소
      - 제어장치(CU)
        - 명령어를 해석해 제어 신호를 보내는 장치.
          - 제어 신호 : 부품을 작동시키기 위한 신호
      - 레지스터(register)
        - CPU 내부의 작은 임시 저장장치.
        - 데이터와 명령어 처리 과정의 중간값을 저장한다.
        - CPU 내부에 여러 레지스터가 존재하며 각기 다른 이름과 역할이 있다.
        - CPU가 처리하는 명령어는 반드시 레지스터에 저장되기에 레지스터 값만 잘 관측하면 프로그램 실행 과정을 파악하기 쉽다.

  - 메모리와 캐시 메모리

    - 실행 중인 프로그램을 구성하는 데이터와 명령어를 저장하는 부품
    - 주소와 휘발성을 바탕으로 프로그램 정보를 제어한다.
      - 주소 : CPU가 원하는 정보로 접근하기 위해 필요
      - 휘발성 : 전원이 공급되지 않을 때 저장하고 있는 정보가 지워지는 특성
    - 캐시 메모리
      - CPU가 조금이라도 더 빨리 메모리에 접근하기 위해 사용하는 저장장치.
      - 메모리와 CPU 사이에 하나 이상 존재한다.

  - 보조기억장치

    - 휘발성 저장장치를 보조하기 위한 비휘발성 저장장치.
    - 하드 디스크, 플래시 메모리, 플로피 디스크 등이 그 예시
    - 프로그램을 실행하기 위해서는 보조기억장치 -> 메모리 복사가 필수적.

  - 입출력장치

    - 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치.
    - 보조기억장치도 입출력장치의 일종으로 볼 수도 있다. (이에 둘을 합쳐 주변장치(peripheral device)라고 통칭하기도 함.)

  - 메인 보드와 버스
    - 메인보드 : 부품들을 고정하고 연결하는 기판.
    - 버스 : 메인 보드에서 각 컴퓨터 부품들이 정보를 주고받는 통로

## 2. 컴퓨터가 이해하는 정보

#### 기본 입력 단위

- 비트
  - CPU가 기본적으로 이해하는 0과 1로 나타내는 가장 작은 정보의 단위.
  - 8bit = 1byte, 1000byte = 1kB, 1000kB = 1MB ....
  - 1024byte = 1kiB 같이 i를 붙인다.
- 워드(word)
  - CPU가 한 번에 처리할 수 있는 데이터의 크기. CPU 관점에서의 정보 단위.
  - 대부분의 워드 크기는 32bit 혹은 64bit이다.

#### 데이터 입력

- 숫자 표현

  - 2진법과 16진법을 자주 활용한다.
  - 소수 표현 시 유의점
    - 소수점을 나타내기 위해 부동 소수점 표현 방식을 사용하기에 오차가 발생한다.
    - 기수(소수 부분), 지수(2^x의 x 부분)로 `IEEE 754` 저장 방식을 사용하는데, 기수 부분이 딱 맞아 떨어지지 않을 때 일부 소수점을 생략하여 저장하기 때문.

- 문자 표현

  - 컴퓨터가 이해할 수 있는 문자들의 집합인 `문자 집합`, 이를 0, 1로 이루어진 문자 코드로 변환하는 과정을 `문자 인코딩`이라 한다.
  - 가장 기본적인 문자 집합에는 `아스키(ASCII)`가 있으며 하나의 아스키 문자는 8비트로 표현한다. 이 때 1비트는 `패러티비트(parity bit)`로 오류 검출을 위해 사용되어 실제로는 7비트로 문자를 표현한다.
  - 한글을 아스키 코드로 표기할 수 없기에 `EUC-KR`이 등장했다. 하나의 한글 글자를 16바이트로 나타낸다.
  - 하지만 이 또한 모든 한글 단어를 표현한 것을 아니기에 `유니코드(unicode)` 문자 집합이 등장했다. 다른 언어와 이모티콘까지 코드로 표현할 수 있는 통일된 문자 집합으로 자주 쓰인다.
    - 인코딩 방법에 따라 UTF-8, UTF-16, UTF-32로 나뉜다. (가변 길이 인코딩)
  - base64 인코딩
    - 이진 데이터까지 변환할 수 있는 인코딩 방식
    - 6비트 단위로 쪼개서 인코딩을 한다.
    - 만약 6으로 나뉘어 떨어지지 않는 경우 부족한 비트는 0으로 간주되어 인코딩된다.

#### 명령어

- 연산 코드와 오퍼랜드

  - 수행할 동작과 수행할 대상으로 이루어져 있다.
    - 연산 코드(opcode) : 명령어가 수행할 동작, `연산자`라고 부름
    - 오퍼랜드(operand) : 동작에 사용될 데이터 혹은 사용될 데이터가 저장된 위치, `피연산자`라고 부름
  - 연산 코드와 0개 이상의 오퍼랜드로 구성되어 있다.
    |유형|연산 코드|설명|
    |------|---|---|
    |데이터 전송|MOVE|데이터를 옮겨라|
    ||STORE|메모리에 저장해라|
    ||LOAD(FETCH)|데이터를 메모리에서 CPU로 가져와라|
    ||PUSH|데이터를 스택에 저장해라|
    ||POP|스택의 최상단 데이터를 가져와라|
    |산술 / 논리 연산|ADD/SUBTRACT/MULTIPLY/DIVIDE|덧셈/뺄셈/곱셈/나눗셈을 수행해라|
    ||INCREMENT|오퍼랜드에 1을 더해라|
    ||DECREMENT|오퍼랜드에 1을 빼라|
    ||AND/OR/NOT|AND/OR/NOT 연산을 수행해라|
    ||COMPARE|두 개의 숫자. 혹은 TRUE/FALSE 값을 비교해라|
    |제어 흐름 변경|JUMP|특정 주소로 실행 순서를 옮겨라|
    ||CONDITONAL JUMP|조건에 부합할 경우 특정 주소로 실행 순서를 옮겨라|
    ||HALT|프로그램의 실행을 멈춰라|
    ||CALL|되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라|
    ||RETURN|CALL을 호출할 때 저장했던 주소로 돌아가라|
    |임출력 제어|READ(INPUT)|특정 입출력장치로부터 데이터를 읽어라|
    ||WRUTE(OUTPUT)|특정 입출력장치로 데이터를 써라|
    ||START IO|입출력 장치를 시작해라|
    ||TEST IO|입출력 장치의 현재 상태를 확인해라|

- 기계어와 어셈블리어

  - 기계어 : CPU가 이해할 수 있도록 0과 1로 표현된 정보를 있는 그대로 표현한 언어.
  - 어셈블리어 : 0과 1로 표현된 기계어를 익기 편한 형태로 단순 번역한 언어

- 명령어 사이클
  - CPU가 명령어를 처리하는 과정에서 일정한 주기를 반복하여 실행되는 사이클
  - 명령어를 CPU로 가져오는 `인출 사이클`, 명령어를 위해 한 번 더 메모리에 접근하는 `간접 사이클`(필요할 경우), 명렁어를 실행하는 `실행 사이클`이 반복된다.
  - 인터럽트가 발생할 경우 `인터럽트 사이클`이 실행된다.

## 3. CPU

#### 레지스터

CPU 안에 있는 작은 임시 저장장치. WinDbg(윈도우 운영체제), gdb(리눅스, 맥OS 운영체제) 등의 디버깅 도구를 이용해 관찰할 수 있다.

- 프로그램 카운터(PC, Program Counter)

  - 메모리에서 다음으로 읽어 들일 명령어의 주소를 저장
  - 명령어 포인터(IP, Instruction Pointer)이라고 부르기도 함.

- 명령어 레지스터(IR, Instruction Register)

  - 메모리에서 방금 읽어 들인 명령어를 저장하는 레지스터.
  - CPU는 레지스터 속 명령어를 해석한 뒤 ALU로 연산시키거나 다른 부품으로 제어 신호를 보내 해당 부품을 작동시킨다.

- 범용 레지스터(geneal purpose register)

  - 다양하고 일반적인 상황에서 자유롭게 사용하는 레지스터. 데이터, 명령어, 주소 모두 저장할 수 있다.

- 플래그 레지스터(flag register)

  - 연산의 결과 혹은 CPU 상태에 대한 부가 정보(플래그(flag)) 값을 저장하는 레지스터.

    - 플래그 : CPU가 명령어를 처리하는 과정에서 반드시 참조해야 할 상태 정보를 의미하는 비트

      | 종류              | 설명                                  | 사용 예시                                                |
      | ----------------- | ------------------------------------- | -------------------------------------------------------- |
      | 부호 플래그       | 연산 결과의 부호                      | 1일 경우 음수, 0일 경우 양수                             |
      | 제로 플래그       | 연산 결과가 0인지                     | 1일 경우 0, 0일 경우 0이 아님                            |
      | 캐리 플래그       | 연산 결과에 올림수나 빌림수 발생 여부 | 1일 경우 발생, 0일 경우 발생하지 않음                    |
      | 오버플로우 플래그 | 오버플로우 발생 여부                  | 1일 경우 오버플로우 발생, 0일 경우 발생하지 않음         |
      | 인터럽트 플래그   | 인터럽트가 가능한지의 여부            | 1일 경우 인터럽트가 가능함, 0일 경우 인터럽트가 불가능함 |
      | 슈퍼바이저 플래그 | 커널 모드인지 사용자 모드인지 여부    | 1일 경우 커널 모드, 0일 경우 사용자 모드                 |

- 스택 포인터(stack pointer)
  - 메모리 내 스택 영역의 최상단 스택 데이터 위치를 가리키는 특별한 레지스터
  - 프로그램 카운터(PC)는 실행할 명령어를, 스택 포인터(SP)는 스택의 최상단(함수 콜 시 변수 정보 등)을 가리킨다는 차이가 있다.

#### 인터럽트

CPU의 작업을 방해하는 신호. 동기 인터럽트(stnchronous interrupts), 비동기 인터럽트(asynchronous interrupts)로 나뉜다.

- 동기 인터럽트 : CPU에 의해 발생한 인터럽트. 예외라고 부른다.
- 비동기 인터럽트 : 입출력장치에 의해 발생하는 인터럽트. 일반적으로 인터럽트는 이를 뜻하지만 책에서는 비동기 인터럽트를 `하드웨어 인터럽트`라 부른다.

- 하드웨어 인터럽트

  - 효율적으로 명령어를 처리하기 위해 사용. (폴링(polling) 기법을 사용하지 않고 인터럽트로 처리)
  - CPU의 하드웨어 인터럽트 처리 순서
    1. 입출력장치는 CPU에 `인터럽트 요청 신호` 보냄
    2. CPU 실행 사이클 끝나고 명령어 호출 전 인터럽트 여부 확인
    3. 인터럽트 요청 확인 시 `인터럽트 플래그`를 통해 현재 인터럽트 가능 여부 확인
    4. 인터럽트 가능 시 CPU가 지금까지의 작업 백업
    5. CPU는 `인터럽트 벡터`를 참조해 `인터럽트 서비스 루틴` 실행
    6. 인터럽트 서비스 루틴 완료 시 백업 작업 복구 후 재개
  - 인터럽트 요청 신호
    - CPU에게 인터럽트의 가능 여부 확인을 위한 신호
  - 인터럽트 플래그
    - CPU가 인터럽트 요청을 수용할 수 있을지 판단하기 위한 정보
    - 0으로 설정되어 있어도 정전이나 하드웨어 고장으로 인한 인터럽트는 막을 수 없다. (non maskable interrupt)
  - 인터럽트 서비스 루틴(ISR)
    - 인터럽트 핸들러라고도 하며 어떤 인터럽트가 발생했을 때 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램이다.
    - 인터럽트 서비스 루틴을 실행하는 것은 본질적으로 함수를 실행하는 것과 다르지 않다.
  - 인터럽트 백터
    - 인터럽트 서비스 루틴을 식별하기 위한 정보
    - CPU는 하드웨어 인터럽트를 보낸 대상으로부터 버스를 통해 인터럽트 백터를 전달받는다.
  - 백업
    - 현재 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업.
    - 인터럽트 서비스 루틴 실행 후 스택에 저장해 둔 프로그램 카운터 등을 다시 불러와 다시 작업 수행

- 예외
  - 폴트, 트랩, 중단, 소프트웨어 인터럽트 등이 있다.
  - CPU는 예외 발생 시 하던 일을 중단하고 해당 예외를 처리한다.
  - 폴트
    - 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
    - 명령어 실행에 필요한 데이터가 보조기억장치에만 존재할 때 발생하는 예외 처리(페이지 폴트)
  - 트랩
    - 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
    - 디버깅의 브레이크 포인트(특정 코드가 실행되는 순간에 프로그램을 멈추게 하는 것)
  - 중단
    - 프로그램을 강제로 중단시킬 수밖에 없는 상황일 때 발생하는 예외
  - 소프트웨어 인터럽트
    - 시스템 콜이 발생했을 때 발생하는 예외

#### CPU 성능 향상을 위한 설계

- CPU 클럭 속도
  - 클럭
    - 컴퓨터 부품을 일사불란하게 움직일 수 있게 하는 시간 단위.
    - 헤르츠(Hz) 단위로 측정된다.
    - 현재의 CPU는 클럭이 GHz 단위로 측정된다.
  - 멀티코어와 멀티스레드
    - 코어
      - CPU 내에서 명령어를 읽어 들이고, 해석하고, 실행하는 부품. 원칙적으로는 CPU 하나만 존재할 수 있으나 기술의 발달로 CPU 내에 이 같은 부품들이 여러개 존재하게 되었다.
      - 여러 개의 코어를 포함한 CPU는 `멀티코어 CPU`, 혹은 `멀티코어 프로세서`라고 부른다.
    - 스레드
      - 실행 흐름의 단위. 하드웨어 스레드와 소프트웨어 스레드로 나뉘어 짐.
      - 하드웨어 스레드
        - 하나의 코어가 동시에 처리하는 명령어의 단위
        - 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 `멀티스레드 CPU`, 혹은 `멀티스레드 프로세서`라고 부른다.
        - 프로그램의 입장에서는 하드웨어 스레드가 1개의 코어랑 다름없기에 4개의 CPU가 존재하는 것처럼 보인다. 이에 `논리 프로세서`라고 부르기도 한다.
      - 소프트웨어 스레드
        - 하나의 프로그램에서 독립적으로 실행되는 단위
      - 동시성과 병렬성
        - 병렬성 : 작업을 물리적으로 동시에 처리하는 성질
        - 동시성 : 동시에 작업을 처리하는 것처럼 보이는 성질
        - 하드웨어 스레드는 병렬성을 구현하기 위한 물리적인 실행 단위, 소프트웨어 스레드는 동시성을 구현하기 위한 논리적인 실행 단위에 가깝다.
  - 파이프라이닝을 통한 명령어 병렬 처리
    - 명령어 병렬 처리 기법(ILP, Instruction-Level Parallelism)
      - 여러 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시켜 CPU의 성능을 높이는 기법
      - 명령어 파이프라이닝
        - 명령어는 `명령어 인출 -> 명령어 해석 -> 명령어 실행 -> 결과 저장` 순서로 이루어짐. 같은 단계가 겹치지 않는다면 CPU가 각각의 단계를 동시 실행할 수 있다.
        - 이를 활용해 명령어를 동시에 처리하기 위해 명령어들을 명령어 파이프라인에 넣고 처리하는 기법.
        - CISC, RISC인지에 따라 효율성이 다르다.
          - CISC는 RISC에 비해 명령어의 수행 시간이 길고 들쑥날쑥하기 때문
        - `파이프라인 위험`이라는 성능 향상이 이루어지지 않는 상황이 존재.
          - 데이터 위험과 제어 위험, 구조적 위험으로 구분할 수 있다.
            - 데이터 위험 : 명령어 간의 데이터 의존성에 의해 발생
            - 제어 위험 : 프로그램 카운터의 급작스러운 변화에 의해 발생
            - 구조적 위험 : 명령어를 겹처 실행할 때 서로 다른 명령어가 동시에 ALU, 레지스터 등 같은 CPU 부품을 사용하려고 할 때 발생. `자원 위험`이라고도 부른다.

## 4. 메모리

#### RAM

휘발성 저장장치이며 `순차 접근`이 아닌 `임의 접근(직접 접근)` 할 수 있는 메모리.

- RAM의 종류
  - DRAM(Dynamic RAM)
    - 시간이 지나면 저장된 데이터가 점차 사라지는 RAM
    - 소비 전력이 낮고, 저렴하고, 집적도가 높아 메모리를 대용량으로 설계하기 용이
  - SRAM(Static RAM)
    - 시간이 지나도 저장된 데이터가 사라지지 않는 RAM
    - DRAM과 비교해 속도는 빠르지만, 소비 전력이 크고 가격도 비싸고 집적도도 낮아 대용량으로 만들 필요는 없지만 속도가 빨라야 하는 `캐시 메모리` 등에 활용
  - SDRAM(Synchronous Dynamic RAM)
    - 클럭 신호와 동기화된 보다 발전된 형태의 DRAM
    - 클럭 타이밍에 맞춰 작동하며 PU와 정보를 주고받을 수 있는 DRAM
  - DDR SDRAM(Double Data Rate SDRAM)
    - 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
    - 한 클럭 당 두 번씩 CPU와 데이터를 주고받을 수 있는 SDRAM
    - 현재 사용하는 DDR4 SDRAM은 SDR SDRAM보다 16배 넓은 대역폭을 가진 SDRAM이다. (2는 1의 2배, 3은 2의 2배, 4는 3의 2배)

#### 메모리 저장 방식

현대의 메모리는 대부분 데이터를 바이트 단위로 저장하고 관리한다. 하지만 CPU는 바이트 단위가 아닌 4바이트(32비트), 8바이트(64비트)로 받아들인다.

- 빅 엔디안, 리틀 엔디안
  - 빅 엔디안
    - 낮은 번지의 주소에 상위 바이트(가장 큰 값)부터 저장하는 방식
    - MSB(Most Significant Bit, 숫자의 크기에 가장 큰 영향을 미치는 유효 숫자)부터 저장하는 방식
    - 일상적으로 숫자 체계를 읽고 쓰는 순서와 동일해 메모리 값을 직접 읽거나 디버깅 할 때 편리
  - 리틀 엔디안
    - 낮은 번지의 주소에 하위 바이트부터 저장하는 방식
    - LSB(Least Significant Bit, 숫자의 크기에 가장 작은 영향을 미치는 유효 숫자)부터 저장하는 방식
    - 메모리 값을 직접 읽고 쓰기에 불편하지만, 수치 계산에 편리하다.

#### 캐시 메모리

CPU가 메모리에 접근하는 속도가 CPU가 레지스터에 접근하는 속도보다 느리기에 CPU의 빠른 연산 속도를 최대로 활용하기 위해 등장한 SRAM 기반의 저장장치

- 캐시 메모리의 종류

  - 코어에 가장 가까운 L1, 그 다음 L2, 다음 L3로 나뉜다.
  - 일반적으로 L1, L2는 코어 내부에, L3는 코어 외부에 위치한다.
  - 캐시 메모리의 크기는 L1 < L2 < L3, 속도는 L1 > L2 > L3 순이다.
  - CPU가 메모리 내에 데이터가 필요하다 판단 시 L1, L2, L3 순으로 데이터를 탐색한다.
  - L1, L2는 각 코어에 고유한 캐시 메모리로 할당되고, L3는 여러 코어가 공유하는 형태가 일반적이다.
  - L1은 추가적으로 명령어만을 저장하는 L1I 캐시와 데이터만을 저장하는 L1D 캐시로 구분하기도 한다.(분리형 캐시(split cache)일 경우)

- 캐시 히트와 캐시 미스

  - 캐시 히트
    - 캐시 메모리에 저장한 데이터가 CPU에 의해 실제로 사용되는 경우
  - 캐시 미스
    - 캐시 메모리에 저장한 데이터가 CPU에 의해 실제로 사용되지 않는 경우
  - 캐시 적중률
    - 캐시 히트 횟수 / (캐시 히트 횟수 +캐시 미스 횟수)
    - 범용적으로 사용되는 컴퓨터의 캐시 적중률은 대략 85% ~ 95%가 나온다.
  - 참조 지역성의 원리
    - 시간 지역성과 공간 지역성을 바탕으로 CPU가 사용할 법한 데이터를 예측하여 캐시 적중률을 높히는 원칙
      - 시간 지역성 : 최근에 접근했던 메모리 공간에 다시 접근하려는 경향
      - 공간 지역성 : 접근한 메모리 근처에 접근하려는 경향

- 캐시 메모리의 쓰기 정책과 일관성
  - 즉시 쓰기(write-through)
    - 캐시 메모리와 메모리를 동시에 쓰는 방법
    - 일관성이 깨지는 상황을 방지할 수 있다.
      버스의 사용 시간과 쓰기 시간이 늘어난다는 단점이 있다.
  - 지연 쓰기(write-back)
    - 캐시 메모리에만 값을 써 두었다가 추후 수정된 데이터를 한 번에 메모리에 반영하는 방법
    - 즉시 쓰기 방식에 비해 속도는 더 빠르지만 메모리와 캐시 메모리 간의 일관성이 깨질 수 있다.
  - L3 캐시 메모리는 여러 코어가 공유하기에 코어 간 캐시 메모리의 불일치도 발생할 수 있다. 이를 위한 `캐시 일관성 프로토콜`이 존재한다.

## 5. 보조기억장치와 입출력장치

#### RAID(Redundant Array of Independent Disks)

데이터의 안정성 혹은 성능을 확보하기 위해 여러 개의 독립적인 보조기억장치를 마치 하나의 보조기억장치처럼 사용하는 기술

- RAID 레벨
  - RAID0
    - 데이터를 여러 보조기억장치에 단순하게 나누어 저장하는 구성 방식
    - 줄무늬처럼 분산되어 저장된 데이터를 스트라입(stripe)이라고 하고, 이렇게 분산하여 저장하는 동작을 스트라이핑(striping)이라고 한다.
    - 빠른 입출력 속도를 보장하지만 데이터가 하나의 디스크에 저장되어 저장된 정보가 안전하지 않다는 단점이 있다.
  - RAID1
    - 완전한 복사본을 만들어 저장하는 구성 방식. 미러링(mirroring)이라고도 부른다.
    - 복구가 간단하고 안전성이 높다는 장점이 있다.
    - 복사본이 저장된 크기만큼 사용 가능한 용량이 적어진다는 단점도 있다.
  - RAID4
    - 패리티 정보를 저장하는 디스크를 따로 두는 구성 방식
      - 패리티(parity) : 오류를 검출할 수 있는 정보
    - RAID1에 비해 적은 하드 디스크로도 안전하게 데이터를 보관할 수 있다.
    - 패리티를 저장하는 장치에 병목 현상이 발생한다는 단점이 있다.
  - RAID5
    - 패리티를 분산하여 저장하는 구성 방식.
    - RAID4의 병목 현상을 보완할 수 있다.
  - RAID6
    - 서로 다른 2개의 패리티를 두는 구성 방식
    - 오류를 검출하고 복구할 수 있는 수단이 2개로 더욱 안정성이 높다.
    - 패리티 2개를 저장하고, 수정해야 하므로 쓰기 속도는 RAID5에 비해 느리다.
  - Nested RAID
    - RAID 레벨을 혼합항 방식
    - RAID 10, RAID 50 등 각 RAID 레벨을 혼합하여 사용하는 경우이다.

#### 입출력 기법

- 장치 컨트롤러와 장치 드라이버

  - 장치 컨트롤러
    - CPU와 입출력 장치 사이의 통신을 중개하는 중개자 역할의 하드웨어
    - 장치 컨트롤러에는 RAM과 같은 저장장치가 있는 경우가 많다.(CPU와 정보 주고받을 때 활용)
  - 장치 드라이버
    - 장치 컨트롤러의 동작을 알고, 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있도록 하는 프로그램
    - 대중적인 장치 드라이버는 기본적으로 윈도우, 맥OS 같은 운영체제에 포함되어 있는 경우가 많다.

- CPU와 장치 컨트롤러의 작업 수행
  - 프로그램 입출력(Programmed I/O)
    - 프로그램 속 명령어로 입출력 작업을 수행하는 방법
    - 입출력장치에 접근하는 주소를 별도로 보관하는지, 메모리에 부여된 주소 공간 일부에 주소를 보관하는지에 따라 `고립형 입출력`과 `메모리 맵 입출력`으로 나뉜다.
  - 인터럽트 기반 입출력: 다중 인터럽트
    - 인터럽트가 여러 입출력장치로부터 동시다발적으로 발생하는 경우 보통 우선순위가 높은 순으로 처리한다.
    - 프로그래머블 인터럽트 컨트롤러(PIC)라는 하드웨어를 통해 다중 인터럽트를 처리한다. (PIC가 NMI까지 우선순위를 판별하지는 않는다.)
  - DMA 입출력(Direct Memory Access)
    - 입출력장치와 메모리 사이에 전송되는 모든 데이터가 CPU를 지날 경우 CPU 부하가 커질 것이기에 CPU를 거치지 않고 입출력장치와 메모리가 상호작용할 수 있도록 만든 입출력 방식
    - 입출력장치들은 DMA 컨트롤러가 존재할 경우 `입출력 버스`라는 입출력장치 컨트롤러 전용 버스와 연결된다.
    - DMA 컨트롤러 동작 과정
      1. CPU가 DMA 컨트롤러에게 정보와 함께 입출력 작업을 명령
      2. DMA 컨트롤러가 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행 (필요할 경우 메모리에 직접 접근)
      3. 입출력 작업 종료 시 DMA 컨트롤러는 CPU에게 인터럽트를 걸어 작업이 끝났음을 알림
    - 버스는 동시 사용이 불가능하기에 CPU가 시스템 버스를 사용하지 않거나 양보했을 때 DMA 컨트롤러가 동작한다. (이를 사이클 스틸링(cycle stealing)이라 한다.)
    - PCIe(Peripheral Component Interconnect express)가 그 예시이다.
      -PCIe는 레인(lane)을 통해 정보를 송수신하며, 버전 숫자가 올라갈수록 레인당 최대 속도가 빨라진다.


- 파이프라이닝이 병렬성, 동시성 중 어떤 것을 만족하는가?

  - 병렬성(Parallelism) : 여러 연산을 물리적으로 동시에 수행

  - 동시성(Concurrency) : 여러 독립 작업을 논리적으로 동시에 수행

  - 파이프라이닝 : 명령어의 단계를 나누어 물리적인 동시에 실행(단계를 나누어 각 단계를 동시적으로 실행). 파이프라이닝은 보통 한 프로그램(또는 스레드)의 명령어 스트림만을 분해하여 가속하는 기법. 파이프라이닝은 동시에 실행하는 것처럼 보이는 것이 아니라 실제로 겹처서 실행하여 물리적인 동시를 만족한다.