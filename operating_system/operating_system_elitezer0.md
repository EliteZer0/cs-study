# 1. 운영체제의 큰 그림

## 운영체제란?

운영체제는 특별한 프로그램이다. 대표적으로 윈도우, 맥OS, 리눅스, 안드로이드, iOS가 있다.
운영체제는 매우 다양한 기능을 제공하지만, 핵심적인 기능은 유사하다.

운영체제의 핵심 기능을 담당하는 부분을 **커널(kernel)** 이라 한다.

`운영체제 = 커널 + 시스템 콜`

---

## 운영체제의 역할

운영체제는 사용자가 실행하는 응용 프로그램 대신 CPU, 메모리, 보조기억장치 등 자원을 효율적으로 관리한다.

### CPU 관리: CPU 스케줄링

- CPU는 한정된 자원이기 때문에 운영체제는 CPU를 할당할 순서를 공정하게 정한다.
- 주요 개념: **우선순위**, **스케줄링 큐**, **선점형과 비선점형**

1. 우선순위 (Priority)

   프로세스마다 중요도를 설정하여, 더 높은 우선순위를 가진 프로세스가 먼저 CPU를 할당받는다.

   우선순위는 동적으로 변할 수 있으며, Priority Scheduling 알고리즘에서 핵심 요소로 사용된다.

   주의할 점: 낮은 우선순위 프로세스가 영원히 CPU를 못 받는 기아(Starvation) 현상이 발생할 수 있다.

2. 스케줄링 큐 (Scheduling Queue)

   - 준비 큐(Ready Queue): 실행을 기다리는 프로세스들이 대기하는 큐.

   - 작업 큐(Job Queue): 시스템에 들어온 모든 프로세스가 처음 대기하는 큐.

   - 장치 큐(Device Queue): 입출력 완료를 기다리는 프로세스들이 대기하는 큐.

   프로세스는 여러 큐를 오가며 상태가 변화한다.

3. 선점형과 비선점형 (Preemptive vs Non-preemptive)

   - 선점형(Preemptive):

     - 현재 CPU를 사용 중인 프로세스라도, 더 높은 우선순위 프로세스가 나타나면 CPU를 빼앗긴다.
     - 반응성이 중요할 때(예: 실시간 시스템) 선호된다.

   - 비선점형(Non-preemptive):
     - 현재 CPU를 사용 중인 프로세스가 자발적으로 CPU를 반납할 때까지 기다린다.
     - 프로세스가 종료하거나, 입출력 요청 시 CPU를 반납한다.
     - 프로세스 간 충돌이 적어 안정성이 높다.

### 메모리 관리: 가상 메모리

- 프로그램 실행에 필요한 메모리를 관리하고, 가상 메모리 기술을 통해 큰 메모리 공간을 제공한다.

### 파일/디렉터리 관리: 파일 시스템

- 파일 시스템을 통해 보조기억장치의 정보를 체계적으로 저장/관리한다.

---

## 프로세스 및 스레드 관리

- 프로세스는 실행 중인 프로그램
- 스레드는 프로세스 내 실행 단위

운영체제는 프로세스와 스레드의 자원 할당을 조율한다.

---

## 시스템 콜과 이중 모드

- **커널 모드**: 운영체제 코드를 실행
- **사용자 모드**: 응용 프로그램 코드를 실행

시스템 콜을 통해 사용자 프로그램이 커널 기능을 요청한다.

---

# 2. 프로세스와 스레드

## 프로세스 구조

메모리 영역:

- 코드 영역 (읽기 전용)
- 데이터 영역 (전역 변수 저장)
- 힙 영역 (동적 메모리 할당)
- 스택 영역 (함수 호출 및 복귀 주소 저장)

프로세스 제어 블록(PCB):

- 프로세스 상태, PID, CPU 스케줄링 정보, 메모리 정보, 파일 정보 저장

---

## 프로세스 문맥 교환 (Context Switching)

- 타이머 인터럽트 발생 시 프로세스의 문맥을 PCB에 저장하고 다른 프로세스의 문맥을 복구
- 문맥 교환이 너무 잦으면 오버헤드 발생

---

## 프로세스 상태

- 생성(new)
- 준비(ready)
- 실행(running)
- 대기(blocked)
- 종료(terminated)

---

## 멀티프로세스와 멀티스레드

### 멀티프로세스

- 각 프로세스가 독립적인 메모리 공간을 사용
- 한 프로세스가 문제를 일으켜도 다른 프로세스에 영향 없음

### 멀티스레드

- 같은 프로세스 내 여러 스레드가 메모리 공간을 공유
- 스레드 간 통신이 빠르지만, 한 스레드 문제 발생 시 전체 프로세스에 영향

---

## 프로세스 간 통신 (IPC)

- 공유 메모리 방식
- 메시지 전달 방식
- 파이프, 시그널, 소켓, RPC

공유 메모리는 빠르지만 동기화 문제 주의.  
메시지 전달은 안정성 높지만 상대적으로 느림.

---

## 3. 동기화와 교착 상태

### 프로세스 간 통신 상황

- 프로세스 A가 공유 메모리에 쓰고, 프로세스 B가 읽을 때와 같이 공유 자원을 동시에 사용하는 경우, 타이밍 문제 발생 가능
- 동일한 자원(메모리, 파일 등)을 여러 프로세스나 스레드가 접근할 때 충돌 가능성 존재

### 임계 구역 (Critical Section)

- 여러 프로세스/스레드가 동시에 접근하면 문제가 발생할 수 있는 코드 영역
- 임계 구역 문제를 해결하지 않으면 데이터 손상 및 오류 발생

### 레이스 컨디션 (Race Condition)

- 두 개 이상의 프로세스/스레드가 동시에 임계 구역에 진입해 충돌하는 문제
- 실행 결과가 스케줄링에 따라 달라지는 현상
- 해결 방법: 동기화(synchronization) 적용

### 동기화 방법

- 실행 순서 제어: 프로세스 및 스레드 실행 순서를 조정
- 상호 배제: 한 번에 하나만 임계 구역에 접근하도록 제한

### 동기화 구현: 뮤텍스 락 (Mutex Lock)

- **뮤텍스(Mutual Exclusion)**: 상호 배제를 보장하는 동기화 기법
- 입장 시 lock.acquire(), 퇴장 시 lock.release() 방식 사용
- C/C++, Python, Java 등 대부분의 언어에서 기본 제공

### 동기화 적용 전후 비교

- 동기화 미적용: Race Condition 발생 → 공유 데이터 값이 비일관성
- 동기화 적용: 공유 데이터 값이 일관성 있게 유지됨

### 세마포어 (Semaphore)

- 뮤텍스의 확장형 동기화 도구
- 공유 자원의 개수(S)를 관리하여 여러 프로세스/스레드 동시 접근 제어 가능
- wait() : S 값을 1 감소시키고, 0보다 작으면 대기
- signal() : S 값을 1 증가시키고, 대기 중인 프로세스를 깨움
- 생산자-소비자 문제 해결에 주로 사용

### 조건 변수와 모니터

- **조건 변수 (Condition Variable)**: 특정 조건이 만족될 때까지 대기하고, 조건 충족 시 실행 재개
- **모니터 (Monitor)**: 공유 자원과 그 자원을 관리하는 연산(메서드)를 함께 묶은 동기화 도구
- 프로그래밍 언어에서는 synchronized 키워드를 통해 모니터 구현 (ex. Java)
- 모니터 내부에서는 한 번에 하나의 프로세스/스레드만 실행 가능

### 스레드 안전 (Thread Safety)

- 멀티스레드 환경에서도 여러 스레드가 동시에 접근해도 데이터 손상이나 오류가 발생하지 않는 상태
- 예시: Java의 Vector 클래스는 synchronized로 스레드 안전 보장, ArrayList는 기본적으로 스레드 안전 아님

### 교착 상태 (Deadlock)

- 여러 프로세스가 서로 자원을 점유한 채 무한히 대기하는 상태
- 교착 상태 발생 4가지 필요 조건:
  1. 상호 배제 (Mutual Exclusion)
  2. 점유 대기 (Hold and Wait)
  3. 비선점 (No Preemption)
  4. 순환 대기 (Circular Wait)

### 교착 상태 해결 방법

1. 예방 (Prevention)

   - 교착 상태 발생 조건 중 하나를 제거
   - 예: 점유 대기를 막기 위해 필요한 모든 자원을 한 번에 할당

2. 회피 (Avoidance)

   - 교착 상태가 발생하지 않는 안전한 상태로만 시스템을 운영
   - 예: 은행원 알고리즘(Banker's Algorithm)

3. 탐지 및 복구 (Detection and Recovery)
   - 교착 상태를 탐지하고, 복구하는 방법 적용
   - 예: 자원 선점(Resource Preemption)이나 프로세스 종료

### 교착 상태 예방, 회피, 탐지 상세 전략

- **예방**: 자원 요청 순서를 정하고, 역순 요청 방지
- **회피**: 시스템이 항상 안전 상태를 유지하도록 자원 분배
- **탐지 후 복구**: 주기적으로 자원 그래프를 검사하여 교착 상태를 탐지하고, 필요 시 프로세스를 종료하거나 자원을 강제로 회수

### 교착 상태와 기아 상태 (Starvation)

- **기아 상태(Starvation)**: 우선순위가 낮은 프로세스가 자원을 계속 할당받지 못해 실행되지 못하는 상황
- **교착 상태(Deadlock)**: 서로가 서로의 자원을 기다리며 멈춰 있는 상황
- 두 문제는 발생 원인과 형태가 다름

---

## 4. CPU 스케줄링

### CPU 스케줄링 개요

- 운영체제는 다양한 프로세스와 스레드에 CPU 자원을 분배하여 사용을 관리
- CPU 스케줄링(CPU Scheduling): CPU 사용을 관리하고 배분하는 방법
- CPU 스케줄러(CPU Scheduler): CPU 스케줄링을 수행하는 운영체제의 일부

> **실행의 문맥이 있다면 모두 스케줄링 대상**
>
> 프로세스뿐만 아니라 스레드도 CPU 스케줄링 대상이며, 일반적으로 프로세스를 중심으로 설명함

### 우선순위와 CPU 활용률

- 프로세스마다 CPU 자원에 대한 우선순위를 가짐
- CPU 자원을 공정하게 배분하기 위해 PCB(Process Control Block)에 우선순위 정보를 명시
- **CPU 활용률(CPU Utilization)**: 전체 시간 중 CPU가 작업에 사용된 비율을 높이는 것이 목표
- CPU 버스트(CPU Burst): CPU를 집중적으로 사용하는 시간 구간
  - **입출력 집중 프로세스**: CPU 사용보다 입출력 대기 시간이 긴 프로세스
  - **CPU 집중 프로세스**: CPU 사용 시간이 긴 프로세스

### 스케줄링 큐

- 운영체제는 다양한 큐를 통해 프로세스 상태를 관리
- 준비 큐(Ready Queue): CPU를 기다리는 프로세스들의 큐
- 대기 큐(Wait Queue): 입출력을 기다리는 프로세스들의 큐
- 각 입출력 장치마다 별도의 대기 큐를 가질 수 있음

### 선점형 vs 비선점형 스케줄링

- **선점형 스케줄링(Preemptive Scheduling)**: 운영체제가 CPU를 강제로 회수하고 다른 프로세스에 할당
- **비선점형 스케줄링(Non-Preemptive Scheduling)**: 프로세스가 자발적으로 CPU를 반환할 때까지 기다림
- 선점형 스케줄링은 응답성이 좋아지지만 오버헤드 발생 가능성 존재

### CPU 스케줄링 알고리즘

운영체제는 다양한 스케줄링 알고리즘을 통해 CPU를 분배함. 대표적인 알고리즘은 다음과 같음:

1. **선입 선처리 스케줄링 (FCFS)**

   - 먼저 준비 큐에 들어온 프로세스부터 CPU를 사용
   - 긴 프로세스가 앞에 오면 전체 지연(convey effect) 발생 가능

2. **최단 작업 우선 스케줄링 (SJF)**

   - 실행 시간이 짧은 프로세스를 먼저 실행
   - 평균 대기 시간을 최소화할 수 있음

3. **라운드 로빈 스케줄링 (RR)**

   - 각 프로세스에 정해진 시간(타임 슬라이스)을 부여
   - 시간 초과 시 다음 프로세스로 교체

4. **최소 잔여 시간 우선 스케줄링 (SRT)**

   - 남은 실행 시간이 가장 짧은 프로세스를 우선 실행

5. **우선순위 스케줄링 (Priority Scheduling)**

   - 우선순위가 높은 프로세스에게 먼저 CPU 할당
   - 에이징(Aging) 기법으로 기아(starvation) 방지

6. **다단계 큐 스케줄링 (Multilevel Queue Scheduling)**

   - 우선순위에 따라 준비 큐를 여러 개로 분리해 관리

7. **다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue Scheduling)**
   - 프로세스가 실행 특성에 따라 큐 사이를 이동 가능
   - 오랫동안 CPU를 사용하는 프로세스는 점차 낮은 우선순위 큐로 이동

### 리눅스 CPU 스케줄링 정책

리눅스 운영체제에서는 다양한 상황에 따라 스케줄링 정책을 선택적으로 사용함.

- **SCHED_FIFO**: 실시간 프로세스에 적용, 매우 높은 우선순위 부여
- **SCHED_RR**: 실시간 프로세스에 적용, 시간 분할 추가
- **SCHED_NORMAL**: 일반 사용자 프로세스에 적용
- **SCHED_BATCH**: 대량 작업에 최적화
- **SCHED_IDLE**: 매우 낮은 우선순위를 갖는 작업에 적용

> 리눅스에서는 프로세스의 특성에 따라 타임 슬라이스, 우선순위, 큐 이동 등을 동적으로 조정하여 CPU 활용률을 높이고 응답성을 개선함

---

# 5. 가상 메모리

## 가상 메모리 개요

- CPU와 프로세스는 메모리 번지에 무엇이 저장되어 있는지 직접 알지 못함.
- CPU 내부의 레지스터가 메모리 번지를 저장하지만 실제로는 작은 용량만 가짐.
- 메모리에 적재된 프로세스의 주소를 인식하기 위해 가상 메모리와 논리 주소 개념 도입.

## 물리 주소와 논리 주소

- **물리 주소**: 메모리 하드웨어에 실제 존재하는 주소.
- **논리 주소**: 프로세스마다 0번지부터 시작하는 주소 체계.

## 메모리 관리 장치(MMU)

- CPU와 메모리 사이에서 논리 주소를 물리 주소로 변환하는 역할.
- 메모리 관리 장치 덕분에 CPU는 논리 주소만 알고 동작할 수 있음.

## 스와핑(Swapping)

- 실행되지 않는 프로세스를 보조 기억장치로 이동(스왑 아웃), 필요 시 다시 메모리로 복귀(스왑 인).
- 스왑 영역은 보조기억장치의 일부.

## 연속 메모리 할당

- 프로세스를 연속된 물리 메모리 공간에 배치.
- 외부 단편화(External Fragmentation) 발생 문제: 남은 빈 공간이 여러 곳에 흩어짐.

## 페이징(Paging)을 통한 가상 메모리 관리

- 메모리를 고정된 크기인 '페이지'로 나누어 관리.
- 각 페이지는 물리 메모리의 '프레임'에 매핑됨.
- 외부 단편화 문제 해결, 대신 마지막 페이지 공간 낭비로 내부 단편화(Internal Fragmentation) 발생 가능.

## 세그멘테이션(Segmentation)

- 코드, 데이터, 스택 등을 독립적인 논리 단위(세그먼트)로 나눔.
- 세그먼트 단위로 메모리에 할당, 크기가 가변적.

## 페이지 테이블

- 페이지 번호와 프레임 번호를 매핑하는 테이블.
- 각 프로세스마다 페이지 테이블을 가짐.
- **페이지 테이블 엔트리**(PTE): 페이지 번호, 프레임 번호, 유효 비트, 보호 비트, 참조 비트, 수정 비트 포함.

## 페이지 테이블 최적화

- 페이지 테이블을 전부 메모리에 두면 낭비 발생.
- **TLB**(Translation Lookaside Buffer): 최근 참조한 페이지 테이블 엔트리를 캐싱하여 접근 속도 향상.
- **계층적 페이징(Multilevel Paging)**: 페이지 테이블을 여러 단계로 나누어 관리.

## 페이징 주소 체계

- 논리 주소는 [페이지 번호 + 변위(offset)]로 구성.
- 물리 주소는 [프레임 번호 + 변위]로 변환하여 접근.

## 페이지 교체 알고리즘

- **요구 페이징(Demand Paging)**: 필요한 페이지만 메모리에 적재.
- 페이지 폴트(Page Fault) 발생 시 디스크로부터 페이지를 불러옴.
- 대표적인 교체 알고리즘
  - **FIFO**: 가장 먼저 들어온 페이지를 교체.
  - **Optimal**: 앞으로 가장 사용되지 않을 페이지를 교체.
  - **LRU(Least Recently Used)**: 가장 오래 전에 사용된 페이지를 교체.

## 페이지 폴트의 종류

- **메이저 폴트(Major Fault)**: 디스크 접근이 필요한 경우.
- **마이너 폴트(Minor Fault)**: 디스크 접근 없이 메모리만으로 처리 가능한 경우.

---

# 6. 파일 시스템

## 파일과 디렉터리

운영체제는 보조기억장치의 정보를 파일 및 디렉터리(폴더) 형태로 저장하고 관리할 수 있도록 지원한다.

### 파일

- 파일은 이름, 실행 정보, 파일과 관련된 부가 정보(속성, 메타데이터)로 구성된다.
- 메타데이터에는 파일의 형식, 위치, 크기 등이 포함된다.
- 파일을 다루는 작업은 운영체제의 시스템 콜을 통해 이루어진다.

### 디렉터리

- 여러 파일을 일목요연하게 관리하기 위해 사용된다.
- 트리 구조(계층적 구조)로 관리된다.

### 파일 디스크립터

- 프로세스가 파일을 열 때 반환받는 정수형 핸들.
- 리눅스에서는 0(표준 입력), 1(표준 출력), 2(표준 에러)가 예약되어 있다.

## 트리 구조 디렉터리

- 루트 디렉터리(/)를 기준으로 서브 디렉터리가 계층적으로 연결된다.
- 디렉터리 엔트리: 파일 또는 디렉터리 이름과 위치 정보를 함께 저장한다.

## 파일 할당 방식

### 연속 할당

- 파일이 연속된 블록에 저장된다.
- 단점: 외부 단편화 발생.

### 연결 할당

- 파일 블록들이 포인터로 연결된다.
- 디렉터리에 첫 번째 블록만 기록.

### 색인 할당

- 파일의 모든 블록 번호를 하나의 색인 블록에 저장한다.

## 파일 시스템 종류

- 윈도우: NTFS, ReFS
- 리눅스: EXT, EXT2, EXT3, EXT4, XFS, ZFS
- 맥OS: APFS

## 아이노드 기반 파일 시스템

### 아이노드(Inode)

- 파일의 메타데이터(속성, 저장 위치 등)를 저장하는 자료구조.
- 리눅스/유닉스 계열 운영체제에서 사용된다.

### EXT4 파일 시스템 구조

- 부트 블록 → 블록 그룹 (슈퍼블록, 그룹 식별자, 비트맵, 아이노드 테이블, 데이터 블록)

## 하드 링크와 심볼릭 링크

### 하드 링크

- 같은 아이노드를 공유하는 파일.
- 원본 파일 삭제해도 데이터 유지.

### 심볼릭 링크

- 별도의 파일로 원본 파일 경로를 저장.
- 원본 파일 삭제 시 링크가 끊어진다.

## 마운트(Mount)

- 하나의 파일 시스템을 다른 파일 시스템 내 특정 디렉터리에 연결하는 작업.
- 예: USB 메모리를 `/mnt` 디렉터리에 연결.
- 명령어 예시: `mount -t ext4 -o ro /dev/sda /mnt/test`

---

# 추가 학습

## 1. 전원 버튼을 누르고 부팅이 되기까지

- **부팅 (Booting)**  
  컴퓨터 전원을 켜고 운영체제를 메모리에 적재해 실행하는 과정

- **초기 단계**  
  CPU는 RAM이 아닌 **비휘발성 메모리(ROM)** 에서 정보를 읽어 들임

- **BIOS (Basic Input/Output System)**  
  하드웨어 상태를 점검하는 **POST (Power-On Self Test)** 수행 → 이상 없으면 MBR을 읽어옴

- **MBR (Master Boot Record)**  
  부팅을 위해 저장된 특수 영역. 부트스트랩(bootstrap) 프로그램이 있어 커널 위치를 메모리에 적재

- **UEFI (Unified Extensible Firmware Interface)**  
  BIOS를 대체하는 기술. 대용량 디스크 지원, 빠른 부팅, 그래픽 기반 UI 제공

---

## 2. 가상 머신과 컨테이너

- **가상 머신 (Virtual Machine)**
  - 소프트웨어로 구현된 가상의 컴퓨터
  - **하이퍼바이저 (Hypervisor)** 를 통해 여러 가상 머신을 실행
  - 각각 독립적인 운영체제(게스트 OS)를 가짐
  - 대표 프로그램: VirtualBox

---

## 3. 컨테이너 (Container)

- **컨테이너**  
  동일한 커널을 공유하면서 필요한 라이브러리, 코드만 별도로 구성하여 애플리케이션을 실행

- **특징**
  - 가상 머신보다 가볍고 실행 속도가 빠름
  - 리소스 사용 효율이 높음
  - 특정 애플리케이션 실행에 최적화

---

## 4. 컨테이너 오케스트레이션

- **컨테이너 오케스트레이션 (Container Orchestration)**  
  수많은 컨테이너를 자동으로 배포, 스케일링, 네트워킹하는 기술

- **대표 도구: Kubernetes (쿠버네티스)**
  - 다수의 컨테이너를 클러스터 형태로 관리
  - 자동화된 배포, 확장, 복구 지원

---
