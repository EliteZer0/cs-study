# 💻 컴퓨터 구조 개념 정리

## 1. 컴퓨터 구조의 큰 그림

### 컴퓨터 구조의 의미

- **컴퓨터 구조**: 컴퓨터 과학의 가장 근원적인 학문, 하드웨어에 가장 가까운 학문
- **중요성**: 모든 컴퓨터 과학 개념의 기저에는 그 개념을 실행하는 하드웨어 부품이 있음
- 컴퓨터 구조에 대한 이해는 컴퓨터 과학을 이해하기 위한 시작점

### 컴퓨터가 이해하는 정보

1. **데이터**: 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
    - 데이터는 있는 그대로의 정보
    - 컴퓨터와 주고받는 정보나 저장된 정보 자체를 의미
2. **명령어**: 데이터를 활용하는 정보
    - 데이터는 명령어에 종속적인 정보
    - 명령의 대상이자 재료
    - 컴퓨터는 기본적으로 0과 1만 이해할 수 있어 데이터와 명령어 또한 0과 1로 이루어짐

### 컴퓨터의 핵심 부품

1. **CPU(중앙처리장치, Central Processing Unit)**
    - 데이터와 명령어를 읽어 들이고, 해석하고, 실행
    - 사람으로 비유하면 두뇌에 해당하는 부품
    - 주요 구성 요소: 산술논리연산장치(ALU), 제어장치, 레지스터
2. **메모리(주기억장치)**
    - 현재 실행 중인 프로그램을 구성하는 데이터와 명령어를 저장
    - RAM(Random Access Memory)이 주로 사용됨
    - 휘발성 저장장치: 전원이 꺼지면 저장된 정보가 사라짐
3. **캐시 메모리**
    - CPU와 메모리 사이에 위치
    - CPU가 빠르게 메모리에 저장된 값에 접근하기 위한 저장장치
    - 여러 종류가 있음(L1, L2, L3)
4. **보조기억장치**
    - 비휘발성 저장장치: 전원이 꺼져도 저장된 정보가 사라지지 않음
    - 종류: CD-ROM, DVD, 하드 디스크 드라이브(HDD), 플래시 메모리(SSD, USB)
    - 보관할 프로그램을 저장
5. **입출력장치**
    - 컴퓨터 외부에 연결되어 내부와 정보를 교환하는 장치
    - 입력장치: 마우스, 키보드, 마이크 등
    - 출력장치: 스피커, 모니터, 프린터 등

### 메인 보드와 버스

- **메인 보드(마더보드)**: 컴퓨터의 핵심 부품들을 고정하고 연결하는 기판
- **버스**: 컴퓨터 부품들이 정보를 주고받는 통로
    - **시스템 버스**: 핵심 부품들을 연결하는 중요한 버스(몸을 지탱하는 척추와 같음)

### 저장장치의 계층 구조

- **계층 순서**(CPU와의 거리 기준): 레지스터 → 캐시 메모리 → 메모리 → 보조기억장치
- **특성 비교**:
    - **속도**: 빠름 → 느림
    - **용량**: 작음 → 큼
    - **가격**: 비쌈 → 저렴함
- 각각의 상반된 특성으로 인해 계층별 저장장치를 모두 함께 사용하는 것이 일반적

## 2. 컴퓨터가 이해하는 정보

### 비트와 바이트

- **비트(bit)**: 0 또는 1을 나타내는 가장 작은 정보 단위
- **바이트(byte)**: 8비트, 2^8 = 256개의 정보 표현 가능
- **정보 단위**:
    - 1 byte = 8 비트
    - 1 KB = 1,000 바이트
    - 1 MB = 1,000 킬로바이트
    - 1 GB = 1,000 메가바이트
    - 1 TB = 1,000 기가바이트
    - (참고: 1 KiB = 1,024 바이트, 1 MiB = 1,024 KiB 등으로 표현하기도 함)
- **워드(word)**: CPU가 한 번에 처리할 수 있는 데이터 크기
    - 현대 컴퓨터의 워드 크기는 보통 32비트 또는 64비트

### 2진법과 16진법

- **2진법(binary)**: 0과 1만을 사용하여 수를 표현
    - 2진수로 표현된 수는 숫자 뒤에 아래첨자로 (2)를 붙이거나 앞에 0b를 붙임
    - 예: 0b1010 = 10(10)
- **16진법(hexadecimal)**: 0-9, A-F까지 16개 문자를 사용하여 수를 표현
    - 16진수로 표현된 수는 숫자 뒤에 아래첨자로 (16)을 붙이거나 앞에 0x를 붙임
    - 예: 0x1A = 26(10)
    - 16진수는 2진수 표현을 간략화하는데 유용(4비트를 한 자리로 표현)
    - MAC 주소, IPv6 주소 등에 사용

### 부동 소수점

- **부동 소수점(floating point)**: 소수점이 고정되지 않은 실수 표현 방식
- **IEEE 754 표준**: 2진수의 지수와 가수를 다음과 같은 형식으로 저장
- **소수 표현의 한계**: 일부 10진 소수(예: 0.1, 0.2)는 2진 부동소수점으로 정확히 표현 불가능
    - 이로 인해 `0.1 + 0.2 == 0.3`이 false가 되는 현상 발생

### 데이터 - 0과 1로 문자 표현하기

### 문자 집합과 인코딩

- **문자 집합(character set)**: 컴퓨터가 이해할 수 있는 문자들의 집합
- **문자 인코딩(character encoding)**: 문자를 0과 1로 변환하는 과정
- **문자 디코딩(character decoding)**: 0과 1로 표현된 문자를 다시 사람이 이해하는 문자로 변환하는 과정

### 아스키 코드(ASCII)

- 초창기 컴퓨터에서 사용하던 문자 집합
- 영어 알파벳, 아라비아 숫자, 일부 특수 문자 포함
- 7비트(128개 문자) 사용, 8비트 중 1비트는 패리티 비트(오류 검출용)
- 예: 'A'는 10진수 65(2진수 1000001)로 인코딩

### EUC-KR

- 한글을 표현하기 위한 인코딩 방식
- 아스키 문자는 1바이트, 한글은 2바이트 크기의 코드 부여
- 약 2,350개의 한글 단어 표현 가능

### 유니코드(Unicode)

- 전 세계 모든 문자를 표현할 수 있는 통일된 문자 집합
- 한글, 중국어, 일본어 등 다양한 언어와 특수문자, 이모티콘 모두 표현 가능
- 각 문자에 고유한 코드 포인트(code point) 부여

### UTF 인코딩(UTF-8, UTF-16, UTF-32)

- 유니코드 문자에 부여된 값을 인코딩하는 방식
- 가변 길이 인코딩 방식: 인코딩된 결과의 길이가 일정하지 않음
- **UTF-8**: 웹에서 가장 많이 사용되는 인코딩 방식
- **UTF-16**: 윈도우 내부에서 많이 사용하는 인코딩 방식
- **UTF-32**: 모든 문자를 4바이트로 표현하는 방식

### Base64 인코딩

- 바이너리 데이터를 아스키 문자 형태로 표현하는 인코딩 방식
- 주로 이미지 등 바이너리 데이터를 텍스트로 전송할 때 사용(이메일 첨부파일 등)
- 6비트를 하나의 문자로 변환(2^6 = 64개의 문자 사용)

### 명령어

- **명령어 구성**: 연산 코드(수행할 동작) + 오퍼랜드(수행할 대상)
- **연산 코드(operation code)**: 명령어가 수행할 동작
- **오퍼랜드(operand)**: 동작에 사용될 데이터 또는 데이터가 저장된 위치
    - 오퍼랜드 필드는 주소 필드(address field)라고도 부름
- **명령어 종류**:
    - **데이터 전송**: MOVE, STORE, LOAD(FETCH), PUSH, POP
    - **산술/논리 연산**: ADD, SUB, MUL, DIV, AND, OR, NOT
    - **제어 흐름 변경**: JUMP, CONDITIONAL JUMP
    - **입출력 제어**: IN, OUT

### 기계어와 어셈블리어

- **기계어(machine code)**: CPU가 이해할 수 있는 0과 1로 표현된 명령어
- **어셈블리어(assembly language)**: 기계어를 읽기 편한 형태로 단순 번역한 언어
- CPU마다 이해하는 명령어가 다르기 때문에 같은 프로그램이라도 CPU에 따라 다른 기계어로 변환됨
    - **CISC 기반 CPU** (복잡한 명령어 집합): 인텔 x86, x86-64
    - **RISC 기반 CPU** (간소화된 명령어 집합): ARM, 애플 M1

### 명령어 사이클

- **인출 사이클(fetch cycle)**: 메모리에서 명령어를 CPU로 가져오는 단계
- **간접 사이클(indirect cycle)**: 명령어 실행을 위해 추가로 메모리에 접근하는 단계
- **실행 사이클(execution cycle)**: CPU로 가져온 명령어를 실행하는 단계
- **인터럽트 사이클(interrupt cycle)**: 인터럽트를 처리하는 단계

## 3. CPU

### 레지스터

- **레지스터**: CPU 안에 있는 작은 임시 저장장치
    - 데이터와 명령어, 주소 등을 저장
    - 프로그램 실행 과정에서 중간값을 저장
- **주요 레지스터**:
    1. **프로그램 카운터(Program Counter, PC)**
        - 다음으로 읽어 들일 명령어의 주소를 저장
        - 명령어 포인터(Instruction Pointer, IP)라고도 함
        - 일반적으로 1씩 증가하며 순차적 실행 가능
        - 조건문, 리턴문 등으로 프로그램 흐름이 변경될 때 임의의 값으로 변경됨
    2. **명령어 레지스터(Instruction Register, IR)**
        - 해석할 명령어, 즉 메모리에서 읽어 들인 명령어를 저장
        - 제어장치가 이를 해석해 ALU나 다른 부품에 제어 신호 전달
    3. **범용 레지스터(General Purpose Register)**
        - 다양한 상황에서 자유롭게 사용할 수 있는 레지스터
        - 데이터, 명령어, 주소 등 모두 저장 가능
        - CPU 내에 여러 개 존재
    4. **플래그 레지스터(Flag Register)**
        - 연산 결과나 CPU 상태에 대한 부가 정보(플래그) 저장
        - 주요 플래그:
            - **부호 플래그**: 연산 결과가 음수(1)인지 양수(0)인지 표시
            - **제로 플래그**: 연산 결과가 0(1)인지 아닌지(0) 표시
            - **캐리 플래그**: 연산 결과에 올림수나 빌림수 발생 여부 표시
            - **오버플로우 플래그**: 오버플로우 발생 여부 표시
            - **인터럽트 플래그**: 인터럽트 가능 여부 표시
            - **슈퍼바이저 플래그**: 커널 모드(1)인지 사용자 모드(0)인지 표시
    5. **스택 포인터(Stack Pointer)**
        - 메모리 내 스택 영역의 최상단 데이터 위치를 가리키는 레지스터
        - 스택에 데이터를 저장하거나 꺼낼 때 참조됨

### 인터럽트

- **인터럽트(interrupt)**: CPU가 수행 중인 작업을 방해하는 신호
- **인터럽트 종류**:
    1. **동기 인터럽트(예외, Exception)**
        - CPU에 의해 발생하는 인터럽트
        - 프로그래밍 오류와 같은 예상치 못한 상황에서 발생
    2. **비동기 인터럽트(하드웨어 인터럽트)**
        - 주로 입출력장치에 의해 발생하는 인터럽트
        - 입출력 작업 완료 알림이나 입력 알림의 역할
- **인터럽트 처리 과정**:
    1. 입출력장치가 CPU에게 인터럽트 요청 신호를 보냄
    2. CPU는 실행 사이클이 끝나고 인터럽트 여부 확인
    3. 인터럽트 플래그를 통해 인터럽트 수용 가능 여부 확인
    4. 현재 작업 상태를 백업(프로그램 카운터 등을 스택에 저장)
    5. 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
    6. 인터럽트 서비스 루틴 실행 후 백업해둔 작업 복구
- **인터럽트 관련 중요 개념**:
    - **인터럽트 요청 신호**: 인터럽트의 가능 여부를 확인하는 신호
    - **인터럽트 플래그**: 하드웨어 인터럽트를 받아들일지 결정하는 플래그
    - **마스크 가능 인터럽트(maskable interrupt)**: 인터럽트 플래그로 막을 수 있는 인터럽트
    - **마스크 불가능 인터럽트(non-maskable interrupt)**: 인터럽트 플래그로 막을 수 없는 인터럽트
    - **인터럽트 벡터(interrupt vector)**: 인터럽트 서비스 루틴을 식별하기 위한 정보
    - **인터럽트 서비스 루틴(interrupt service routine)**: 인터럽트를 처리하기 위한 프로그램
    - **인터럽트 핸들러(interrupt handler)**: 인터럽트 서비스 루틴의 다른 이름
- **다중 인터럽트 처리**:
    - 여러 장치로부터 동시에 인터럽트가 발생할 경우 우선순위에 따라 처리
    - **PIC(Programmable Interrupt Controller)**: 인터럽트 우선순위를 판별하는 장치
    - 높은 우선순위의 인터럽트는 현재 처리 중인 인터럽트를 일시 중단시킬 수 있음

### 예외(동기 인터럽트)

- **폴트(fault)**: 예외 처리 후 예외가 발생한 명령어부터 실행 재개
    - 예: 페이지 폴트(필요한 데이터가 메모리에 없을 때 발생)
- **트랩(trap)**: 예외 처리 후 예외가 발생한 명령어의 다음 명령어부터 실행 재개
    - 예: 디버깅의 브레이크 포인트
- **중단(abort)**: 심각한 오류로 프로그램을 강제 중단
- **소프트웨어 인터럽트**: 시스템 콜이 발생했을 때 발생하는 예외

### CPU 성능 향상을 위한 설계

### CPU 클럭 속도

- **클럭**: 컴퓨터 부품을 규칙적으로 움직이게 하는 시간 단위
- **클럭 속도**: 초당 클럭이 반복되는 횟수, 헤르츠(Hz) 단위로 측정
- 클럭 속도가 높을수록 CPU 성능이 좋아지나, 발열 증가로 한계 존재

### 멀티코어와 멀티스레드

- **코어(core)**: CPU 내에서 명령어를 읽고, 해석하고, 실행하는 부품
- **멀티코어 CPU**: 여러 개의 코어를 포함하는 CPU
    - 듀얼 코어(2개), 쿼드 코어(4개), 옥타 코어(8개) 등
- **하드웨어 스레드**: 하나의 코어가 동시에 처리하는 명령어의 단위
- **멀티스레드 CPU**: 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- **논리 프로세서(logical processor)**: 메모리 입장에서 본 하드웨어 스레드
- **소프트웨어 스레드**: 하나의 프로그램에서 독립적으로 실행되는 단위
    - 단일 코어에서도 소프트웨어 스레드를 통한 멀티스레딩 가능

### 동시성과 병렬성

- **병렬성(parallelism)**: 작업을 물리적으로 동시에 처리하는 성질
    - 예: 멀티코어 CPU에서 각 코어가 동시에 명령어 처리
- **동시성(concurrency)**: 동시에 작업을 처리하는 것처럼 보이는 성질
    - 예: 싱글 코어에서 작업을 빠르게 전환하며 처리

### 명령어 파이프라이닝

- **명령어 파이프라이닝(instruction pipelining)**: 명령어 처리 과정을 여러 단계로 나누어 여러 명령어를 겹쳐서 실행하는 기법
- **명령어 처리 단계**:
    1. 명령어 인출(Instruction Fetch)
    2. 명령어 해석(Instruction Decode)
    3. 명령어 실행(Execute Instruction)
    4. 결과 저장(Write Back)
- **슈퍼스칼라(superscalar)**: CPU 내부에 여러 개의 파이프라인을 포함하는 구조
    - 공장의 생산 라인을 여러 개 두는 것과 유사
- **CISC vs RISC**:
    - **CISC(Complex Instruction Set Computer)**: 복잡한 명령어들로 구성된 명령어 집합
        - 적은 수의 명령어로 프로그램 실행 가능
        - 명령어 크기와 실행 시간이 일정하지 않아 파이프라이닝에 비효율적
        - 예: 인텔 x86, x86-64
    - **RISC(Reduced Instruction Set Computer)**: 간소화된 명령어 집합
        - 짧고 규격화된 명령어, 1클럭 내외로 실행됨
        - 같은 프로그램에 더 많은 명령어 필요
        - 파이프라이닝에 최적화
        - 예: ARM, 애플 M1

### 파이프라인 위험

- **데이터 위험(data hazard)**: 명령어 간의 데이터 의존성에 의해 발생
- **제어 위험(control hazard)**: 프로그램 카운터의 갑작스러운 변화에 의해 발생
    - JUMP, CONDITIONAL JUMP, 인터럽트 등으로 발생
- **구조적 위험(structural hazard)**: 서로 다른 명령어가 동시에 같은 CPU 부품을 사용하려 할 때 발생
    - 자원 위험(resource hazard)이라고도 함

## 4. 메모리

### RAM

- **RAM(Random Access Memory, 임의 접근 메모리)**: 저장된 요소에 순차적으로 접근할 필요 없이 임의 위치에 곧장 접근 가능
- **직접 접근(direct access)**: 어떤 위치에 접근하든 동일한 시간 소요
- **순차 접근(sequential access)**: 특정 위치에 접근하기 위해 처음부터 순차적으로 접근

### RAM 종류

1. **DRAM(Dynamic RAM)**
    - 시간이 지나면 저장된 데이터가 사라지는 RAM
    - 일정 주기로 데이터를 재활성화(다시 저장)해야 함
    - 소비 전력이 낮고, 저렴하며, 집적도가 높아 대용량 메모리로 적합
    - 일반적인 주기억장치로 사용됨
2. **SRAM(Static RAM)**
    - 시간이 지나도 저장된 데이터가 사라지지 않는 RAM
    - 전원이 공급되지 않으면 여전히 소실됨(휘발성)
    - DRAM보다 속도 빠르지만, 소비 전력 크고 가격 비쌈, 집적도 낮음
    - 캐시 메모리 등에 사용
3. **SDRAM(Synchronous DRAM)**
    - 클럭 신호와 동기화된 DRAM
    - 클럭 타이밍에 맞춰 CPU와 정보 주고받음
4. **DDR SDRAM(Double Data Rate SDRAM)**
    - 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
    - 한 클럭당 두 번씩 CPU와 데이터 주고받음
    - DDR2는 DDR보다 2배, DDR3는 DDR2보다 2배, DDR4는 DDR3보다 2배 빠름
    - 최근에는 DDR4 SDRAM이 많이 사용됨

### 메모리에 바이트를 저장하는 순서

- 메모리는 일반적으로 데이터를 워드(4바이트 또는 8바이트) 단위로 받아들임
- 여러 바이트로 구성된 데이터는 여러 주소에 저장됨

### 빅 엔디안과 리틀 엔디안

- **빅 엔디안(Big-endian)**: 낮은 번지의 주소에 상위 바이트부터 저장
    - 예: 16진수 1A2B3C4D를 a+2번지부터 저장 → a+2:1A, a+3:2B, a+4:3C, a+5:4D
    - 장점: 사람이 읽고 쓰는 순서와 동일해 디버깅 편리
- **리틀 엔디안(Little-endian)**: 낮은 번지의 주소에 하위 바이트부터 저장
    - 예: 16진수 1A2B3C4D를 a+2번지부터 저장 → a+2:4D, a+3:3C, a+4:2B, a+5:1A
    - 장점: 수치 계산에 편리(작은 자릿수부터 계산 가능)
- **MSB(Most Significant Bit)**: 숫자의 크기에 가장 큰 영향을 미치는 비트
- **LSB(Least Significant Bit)**: 숫자의 크기에 가장 작은 영향을 미치는 비트

### 캐시 메모리

- **캐시 메모리(cache memory)**: CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위한 저장장치
- CPU와 메모리 사이에 위치한 SRAM 기반 저장장치
- 메모리에서 CPU가 사용할 데이터를 미리 가져와 저장

### 캐시 메모리 계층

- **L1 캐시**: 코어와 가장 가까운 캐시, 가장 빠름
    - **L1I 캐시**: 명령어만 저장하는 L1 캐시
    - **L1D 캐시**: 데이터만 저장하는 L1 캐시
- **L2 캐시**: L1 다음으로 가까운 캐시
- **L3 캐시**: 코어 외부에 위치, 여러 코어가 공유
- 속도: L1 > L2 > L3, 용량: L1 < L2 < L3

### 캐시 히트와 캐시 미스

- **캐시 히트(cache hit)**: 캐시 메모리가 예측하여 저장한 데이터가 CPU에 의해 실제로 사용되는 경우
- **캐시 미스(cache miss)**: 캐시 메모리에 CPU가 필요로 하는 데이터가 없어 메모리에서 직접 가져와야 하는 경우
- **캐시 적중률(cache hit rate)**: 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
    - 일반적인 컴퓨터의 캐시 적중률은 약 85~95%

### 참조 지역성의 원리

- 캐시 메모리는 참조 지역성의 원리(principle of locality)에 따라 메모리로부터 가져올 데이터를 결정
- **시간 지역성(temporal locality)**: CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향
    - 예: 변수 값은 프로그램 실행 중 여러 번 사용됨
- **공간 지역성(spatial locality)**: CPU는 접근한 메모리 공간의 근처에 접근하려는 경향
    - 예: 배열의 요소들은 메모리에 연속적으로 저장됨

### 캐시 메모리의 쓰기 정책

- **즉시 쓰기(write-through)**: 캐시 메모리와 메모리에 동시에 쓰는 방식
    - 장점: 메모리가 항상 최신 상태 유지, 일관성 유지
    - 단점: 메모리 접근 횟수 증가로 속도 저하
- **지연 쓰기(write-back)**: 캐시 메모리에만 값을 써두었다가 추후 메모리에 반영하는 방식
    - 장점: 메모리 접근 횟수 감소로 속도 향상
    - 단점: 캐시-메모리 간 일관성 깨질 수 있음

### 캐시 일관성 문제

- **캐시 일관성(cache coherence)**: 여러 캐시 간에 동일한 메모리 위치의 데이터가 일치하도록 유지하는 문제
- **캐시 일관성 프로토콜**: 여러 코어/CPU의 캐시 간 일관성을 유지하기 위한 프로토콜

## 5. 보조기억장치와 입출력장치

### 보조기억장치

- **보조기억장치**: 전원이 꺼져도 저장된 정보가 사라지지 않는 비휘발성 저장장치
- **종류**:
    1. **하드 디스크 드라이브(HDD)**: 자기적 방식으로 데이터를 읽고 쓰는 보조기억장치
        - 플래터(원판)와 헤드로 구성
    2. **플래시 메모리 기반 저장장치**: 전기적 방식으로 데이터를 읽고 쓰는 저장장치
        - SSD, USB 메모리, SD 카드 등
- **역할**:
    - 데이터를 안전하게 보관
    - 필요한 정보를 메모리에 전달

### RAID

- **RAID(Redundant Array of Independent Disks)**: 데이터의 안전성/성능을 확보하기 위해 여러 개의 독립적인 보조기억장치를 하나처럼 사용하는 기술
- **RAID 레벨**:
    1. **RAID0**:
        - 데이터를 여러 디스크에 나누어 저장(스트라이핑)
        - 장점: 빠른 입출력 속도(이론상 디스크 수만큼 빨라짐)
        - 단점: 하나의 디스크에 문제가 생기면 전체 데이터 손실
    2. **RAID1**:
        - 완전한 복사본을 만들어 저장(미러링)
        - 장점: 복구가 간단하고 안전성 높음
        - 단점: 쓰기 속도가 느리고, 저장 용량이 절반으로 줄어듦
    3. **RAID4**:
        - 패리티 정보를 저장하는 디스크를 따로 두는 구성
        - 패리티: 오류를 검출할 수 있는 정보
        - 단점: 패리티 디스크에 병목 현상 발생
    4. **RAID5**:
        - 패리티를 분산하여 저장하는 구성
        - RAID4의 병목 현상 해결
    5. **RAID6**:
        - 서로 다른 2개의 패리티를 두는 구성
        - 장점: 안전성 매우 높음
        - 단점: 쓰기 속도가 느림
    6. **Nested RAID**:
        - 여러 RAID 레벨을 혼합한 방식
        - 예: RAID10(RAID1+RAID0), RAID50(RAID5+RAID0)

### 입출력 기법

### 장치 컨트롤러와 장치 드라이버

- **장치 컨트롤러(device controller)**: CPU와 입출력장치 사이의 통신을 중개하는 하드웨어
    - 각 입출력장치마다 고유한 장치 컨트롤러 존재
    - 내부에 RAM과 같은 저장장치 포함
- **장치 드라이버(device driver)**: 장치 컨트롤러의 동작을 알고, 컨트롤러가 컴퓨터 내부와 정보를 주고받도록 하는 프로그램
    - 운영체제에 기본 포함되거나 별도 설치

### 입출력 기법 종류

1. **프로그램 입출력(programmed I/O)**:
    - 프로그램 속 명령어로 입출력 작업을 직접 수행
    - CPU가 입출력 작업을 처음부터 끝까지 직접 관리
    - 두 종류:
        - **고립형 입출력(isolated I/O)**: 입출력장치와 메모리의 주소 공간 분리
        - **메모리 맵 입출력(memory mapped I/O)**: 입출력장치에 메모리 주소 할당
2. **인터럽트 기반 입출력(interrupt-driven I/O)**:
    - 입출력장치가 작업 완료 시 CPU에 인터럽트 발생
    - CPU는 다른 작업 수행 가능하여 효율적
    - **다중 인터럽트 처리**:
        - PIC(Programmable Interrupt Controller): 여러 장치의 인터럽트 우선순위 관리
        - 계층 구조로 다수의 입출력장치 인터럽트 처리
3. **DMA 입출력(Direct Memory Access I/O)**:
    - CPU를 거치지 않고 입출력장치와 메모리가 직접 상호작용
    - **DMA 컨트롤러**: CPU 대신 입출력 작업 수행
    - **DMA 입출력 과정**:
        1. CPU가 DMA 컨트롤러에 입출력 작업 명령
        2. DMA 컨트롤러가 장치 컨트롤러와 상호작용하며 작업 수행(메모리 직접 접근)
        3. 작업 완료 시 CPU에 인터럽트 발생
    - **사이클 스틸링(cycle stealing)**: DMA 컨트롤러가 CPU가 시스템 버스를 사용하지 않을 때 시스템 버스 사용

### PCIe

- **PCIe(Peripheral Component Interconnect Express)**: 대표적인 입출력 버스
- **특징**:
    - 여러 버전 존재(PCIe 3.0, 4.0, 5.0 등)
    - 버전에 따라 최대 속도 다름
    - **레인(lane)**: PCIe 버스를 통해 정보를 송수신하는 단위
        - x1, x4, x8, x16 등으로 표기
        - 레인 수에 따라 대역폭 증가
    - SSD, GPU, 네트워크 인터페이스 카드 등 다양한 장치 연결

### GPU

- **GPU(Graphics Processing Unit)**: 그래픽 처리 장치, 대량의 그래픽 연산을 위해 탄생
- **GPGPU(General-Purpose computing on GPU)**: 그래픽 외 범용적인 목적의 GPU 사용 기술
    - 딥러닝, 가상화폐 채굴 등에 활용

### GPU 특징

- **코어 수**: 수백~수천 개의 코어 포함
- **코어 성능**: 개별 코어 성능은 CPU보다 낮음
- **병렬 처리**: 단순 연산을 병렬적으로 수행하는 데 최적화
- **캐시 및 메모리**: 자체 캐시와 대용량 메모리 포함
- **보조 프로세서**: CPU의 산술 연산을 보조하는 역할

### GPU vs CPU

- **GPU**: 단순 연산을 병렬적으로 빠르게 수행(SIMD 방식)
- **CPU**: 복잡한 연산과 범용적인 작업 수행
- GPU는 CPU를 완전히 대체할 수 없음
    - 운영체제 실행이나 복잡한 명령어 처리 불가

### CUDA

- **CUDA**: 엔비디아가 개발한, GPU 프로그래밍을 위한 플랫폼
- **구성**:
    - **호스트 코드(host code)**: CPU가 실행할 코드
    - **디바이스 코드(device code)**: GPU가 실행할 코드

# 📊 자료구조 개념 정리

## 1. 자료구조의 큰 그림

자료구조(data structure)는 이름 그대로 어떠한 구조로 데이터를 다룰지에 대해 학습하는 과목입니다. 자료구조와 연관된 과목인 알고리즘에 대해서도 함께 알아보겠습니다.

### 자료구조와 알고리즘

- **자료구조**: 데이터를 효율적으로 저장하고 관리하는 방법
- **알고리즘**: 어떤 목적을 이루기 위해 필요한 일련의 연산 절차

자료구조와 알고리즘은 밀접한 연관성이 있습니다. 어떤 자료구조가 사용되었느냐에 따라 사용 가능한 알고리즘이 달라질 수 있습니다.

### 시간 복잡도와 공간 복잡도

- **시간 복잡도**: 입력의 크기에 따른 프로그램 실행 시간의 관계
  - 연산 횟수에 비례하므로 입력 크기에 따른 연산 횟수로 간주됨
  
- **공간 복잡도**: 프로그램이 실행되었을 때 필요한 메모리 자원의 양
  - 입력에 따른 메모리 사용량의 척도

- **빅 오 표기법(Big O Notation)**: 함수의 점근적 상한을 표기하는 방법
  - 시간 복잡도를 표현할 때 주로 사용
  - 입력 크기가 무한대로 커질 때 실행 시간의 상한을 표현
  - 계수와 낮은 차수의 항은 무시하고 최고차항의 차수만 고려

- **대표적인 시간 복잡도 (빠른 순)**:
  - O(1): 상수 시간 복잡도
  - O(log n): 로그 시간 복잡도
  - O(n): 선형 시간 복잡도
  - O(n log n): 선형 로그 시간 복잡도
  - O(n²): 이차 시간 복잡도
  - O(2ⁿ): 지수 시간 복잡도
  - O(n!): 팩토리얼 시간 복잡도

## 2. 배열과 연결 리스트

### 배열

- **정의**: 메모리에 순차적으로 저장된 같은 타입의 변수 집합
- **특징**:
  - 인덱스를 통한 접근이 O(1)로 매우 빠름
  - 크기가 고정됨 (정적 배열의 경우)
  - 삽입/삭제가 O(n)으로 상대적으로 느림 (요소 이동 필요)
  - 메모리에 연속적으로 할당됨

- **배열 연산의 시간 복잡도**:
  - 접근(Access): O(1)
  - 검색(Search): O(n) (정렬되지 않은 경우)
  - 삽입(Insert): O(n)
  - 삭제(Delete): O(n)

- **정적 배열과 동적 배열**:
  - **정적 배열**: 프로그램 실행 전에 크기가 고정된 배열
  - **동적 배열**: 실행 과정에서 크기가 변할 수 있는 배열 (Vector라고도 함)

### 연결 리스트

- **정의**: 노드의 모음으로 구성된 자료구조, 각 노드는 데이터와 다음 노드를 가리키는 포인터로 구성
- **특징**:
  - 동적으로 크기 조절 가능
  - 삽입/삭제가 O(1)로 빠름 (위치를 알고 있을 경우)
  - 특정 위치에 접근하는 데 O(n) 시간 소요
  - 메모리에 연속적으로 할당되지 않음

- **연결 리스트 연산의 시간 복잡도**:
  - 접근(Access): O(n)
  - 검색(Search): O(n)
  - 삽입(Insert): O(1) (위치를 알고 있을 경우)
  - 삭제(Delete): O(1) (위치를 알고 있을 경우)

- **연결 리스트의 종류**:
  - **단일 연결 리스트(Singly Linked List)**: 각 노드가 다음 노드만 가리킴
  - **이중 연결 리스트(Doubly Linked List)**: 각 노드가 이전 노드와 다음 노드를 모두 가리킴
  - **환형 연결 리스트(Circular Linked List)**: 마지막 노드가 첫 번째 노드를 가리키는 형태

## 3. 스택과 큐

### 스택

- **정의**: 한 쪽 끝에서만 데이터를 삽입하고 삭제할 수 있는 LIFO(Last In First Out) 자료구조
- **주요 연산**:
  - Push: 스택의 맨 위에 요소 추가
  - Pop: 스택의 맨 위 요소 제거 및 반환
  - Peek/Top: 스택의 맨 위 요소 확인 (제거하지 않음)
  - isEmpty: 스택이 비어있는지 확인

- **활용 사례**:
  - 함수 호출(Call Stack)
  - 괄호 검사
  - 웹 브라우저의 뒤로가기 기능
  - 실행 취소(Undo) 기능

### 큐

- **정의**: 한 쪽에서는 삽입, 다른 쪽에서는 삭제가 이루어지는 FIFO(First In First Out) 자료구조
- **주요 연산**:
  - Enqueue: 큐의 뒤에 요소 추가
  - Dequeue: 큐의 앞에서 요소 제거 및 반환
  - Front: 큐의 맨 앞 요소 확인 (제거하지 않음)
  - isEmpty: 큐가 비어있는지 확인

- **큐의 종류**:
  - **선형 큐(Linear Queue)**: 기본적인 큐의 형태
  - **원형 큐(Circular Queue)**: 배열의 처음과 끝이 연결된 형태
  - **덱(Deque, Double-Ended Queue)**: 양쪽 끝에서 삽입과 삭제가 모두 가능한 큐
  - **우선순위 큐(Priority Queue)**: 우선순위가 높은 데이터가 먼저 나오는 큐

## 4. 해시 테이블

- **정의**: 키-값 쌍을 저장하는 자료구조, 해시 함수를 사용하여 키를 배열의 인덱스로 변환
- **구성 요소**:
  - 해시 함수: 키를 인덱스로 변환
  - 버킷: 데이터가 저장되는 배열의 각 요소

- **해시 함수**: 임의의 길이를 가진 데이터를 고정된 길이의 데이터로 변환하는 단방향 함수
  - 대표적인 해시 알고리즘: MD5, SHA-1, SHA-256, SHA-512, SHA3, HMAC

- **해시 테이블 연산의 시간 복잡도**:
  - 접근(Access): O(1) (평균 경우)
  - 검색(Search): O(1) (평균 경우)
  - 삽입(Insert): O(1) (평균 경우)
  - 삭제(Delete): O(1) (평균 경우)
  - 최악의 경우(해시 충돌이 많을 때): O(n)

- **해시 충돌 해결 방법**:
  - **체이닝(Chaining)**: 충돌이 발생한 데이터를 연결 리스트로 추가
  - **개방 주소법(Open Addressing)**: 충돌이 발생했을 때 다른 버킷을 찾아 저장
    - 선형 조사법(Linear Probing): 충돌 발생 시 순차적으로 다음 버킷 확인
    - 이차 조사법(Quadratic Probing): 충돌 발생 시 제곱수만큼 떨어진 버킷 확인
    - 이중 해싱(Double Hashing): 두 번째 해시 함수를 사용하여 다음 위치 결정

## 5. 트리

- **정의**: 계층적 구조를 표현하는 비선형 자료구조, 노드와 간선으로 구성

- **용어**:
  - 노드(Node): 데이터를 저장하는 기본 요소
  - 간선(Edge): 노드를 연결하는 선
  - 루트 노드(Root Node): 트리의 최상위 노드
  - 부모 노드(Parent Node): 특정 노드의 상위 노드
  - 자식 노드(Child Node): 특정 노드의 하위 노드
  - 형제 노드(Sibling Node): 같은 부모를 가진 노드
  - 리프 노드(Leaf Node): 자식이 없는 노드
  - 레벨(Level): 루트에서 특정 노드까지의 경로 길이
  - 높이(Height): 루트에서 가장 먼 리프까지의 경로 길이
  - 차수(Degree): 노드가 가진 자식 노드의 수
  - 서브트리(Subtree): 트리 내의 부분 트리

- **트리의 순회 방법**:
  - **전위 순회(Preorder)**: 루트 → 왼쪽 서브트리 → 오른쪽 서브트리
  - **중위 순회(Inorder)**: 왼쪽 서브트리 → 루트 → 오른쪽 서브트리
  - **후위 순회(Postorder)**: 왼쪽 서브트리 → 오른쪽 서브트리 → 루트
  - **레벨 순서 순회(Level-order)**: 레벨별로 노드를 순회 (BFS와 유사)

### 이진 트리

- **정의**: 각 노드가 최대 2개의 자식을 가질 수 있는 트리
- **종류**:
  - **정 이진 트리(Full Binary Tree)**: 모든 노드가 0개 또는 2개의 자식을 가짐
  - **완전 이진 트리(Complete Binary Tree)**: 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있고, 마지막 레벨은 왼쪽부터 채워짐
  - **포화 이진 트리(Perfect Binary Tree)**: 모든 내부 노드가 2개의 자식을 가지고, 모든 리프 노드가 같은 레벨에 있음
  - **편향 이진 트리(Skewed Binary Tree)**: 한쪽으로만 노드가 연결된 트리

### 이진 탐색 트리(BST)

- **정의**: 왼쪽 서브트리의 모든 노드는 루트보다 작고, 오른쪽 서브트리의 모든 노드는 루트보다 큰 이진 트리
- **연산의 시간 복잡도**:
  - 접근(Access): O(log n) (평균), O(n) (최악, 편향된 경우)
  - 검색(Search): O(log n) (평균), O(n) (최악)
  - 삽입(Insert): O(log n) (평균), O(n) (최악)
  - 삭제(Delete): O(log n) (평균), O(n) (최악)

### 균형 이진 탐색 트리

- **정의**: 트리의 높이를 최소화하여 연산의 효율성을 보장하는 이진 탐색 트리
- **종류**:
  - **AVL 트리**: 노드의 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1인 이진 탐색 트리
  - **레드-블랙 트리(RB Tree)**: 노드에 색(레드/블랙)을 부여하여 균형을 유지하는 이진 탐색 트리
    - 모든 노드는 빨간색 또는 검은색
    - 루트 노드는 검은색
    - 모든 리프 노드(NIL)는 검은색
    - 빨간색 노드의 자식은 모두 검은색
    - 임의의 노드에서 그 노드의 모든 리프 노드까지의 경로에 있는 검은색 노드 수는 같음

### 힙(Heap)

- **정의**: 완전 이진 트리 기반의 자료구조, 부모 노드와 자식 노드 간의 대소 관계가 있음
- **종류**:
  - **최대 힙(Max Heap)**: 부모 노드의 값이 자식 노드보다 크거나 같음
  - **최소 힙(Min Heap)**: 부모 노드의 값이 자식 노드보다 작거나 같음

- **연산의 시간 복잡도**:
  - 삽입(Insert): O(log n)
  - 삭제(Delete): O(log n)
  - 최대/최소값 조회: O(1)

- **활용 사례**: 우선순위 큐, 힙 정렬

### B-트리와 B+트리

- **B-트리**: 자식 노드가 여러 개 있을 수 있는 균형 트리, 디스크 기반 저장에 유리
  - 모든 리프 노드가 같은 레벨에 있음
  - 각 노드는 여러 개의 키와 자식 포인터를 가짐
  - 데이터베이스 인덱싱에 주로 사용

- **B+트리**: B-트리의 변형으로, 리프 노드에만 데이터를 저장
  - 모든 키가 리프 노드에 저장됨
  - 리프 노드들은 연결 리스트로 연결됨
  - 범위 검색에 효율적

## 6. 그래프

- **정의**: 정점(Vertex)과 간선(Edge)으로 구성된 비선형 자료구조
- **용어**:
  - 정점(Vertex): 그래프의 기본 단위(노드)
  - 간선(Edge): 정점을 연결하는 선
  - 인접(Adjacent): 두 정점이 간선으로 직접 연결된 상태
  - 경로(Path): 정점들의 연속된 시퀀스
  - 사이클(Cycle): 시작 정점과 끝 정점이 같은 경로

- **그래프의 종류**:
  - **방향 그래프(Directed Graph)**: 간선에 방향이 있는 그래프
  - **무방향 그래프(Undirected Graph)**: 간선에 방향이 없는 그래프
  - **가중치 그래프(Weighted Graph)**: 간선에 가중치가 있는 그래프
  - **연결 그래프(Connected Graph)**: 모든 정점 쌍 사이에 경로가 있는 그래프
  - **비연결 그래프(Disconnected Graph)**: 일부 정점 사이에 경로가 없는 그래프
  - **완전 그래프(Complete Graph)**: 모든 정점 쌍이 간선으로 연결된 그래프
  - **서브그래프(Subgraph)**: 원래 그래프의 일부 정점과 간선으로 구성된 그래프

- **그래프의 표현 방법**:
  - **인접 리스트(Adjacency List)**: 각 정점에 연결된 정점들을 리스트로 표현
    - 공간 복잡도: O(V + E) (V: 정점 수, E: 간선 수)
    - 두 정점 연결 여부 확인: O(degree(V))
    - 모든 간선 순회: O(V + E)

### 그래프 탐색 알고리즘

#### 깊이 우선 탐색(DFS, Depth-First Search)

- **정의**: 그래프에서 최대한 깊이 탐색하고 더 이상 갈 곳이 없을 때 되돌아가는 방식
- **구현 방법**:
  - 재귀 함수 사용
  - 스택 자료구조 사용
- **과정**:
  1. 시작 정점을 방문 처리
  2. 인접한 미방문 정점이 있으면 방문
  3. 더 이상 방문할 정점이 없으면 이전 정점으로 돌아감
  4. 모든 정점을 방문할 때까지 2-3 반복
- **시간 복잡도**: O(V + E)
- **활용 사례**: 경로 탐색, 사이클 감지, 위상 정렬

#### 너비 우선 탐색(BFS, Breadth-First Search)

- **정의**: 그래프에서 같은 레벨의 정점들을 모두 방문한 후 다음 레벨로 진행하는 방식
- **구현 방법**: 큐 자료구조 사용
- **과정**:
  1. 시작 정점을 큐에 넣고 방문 처리
  2. 큐에서 정점을 꺼내 인접한 미방문 정점을 모두 큐에 넣고 방문 처리
  3. 큐가 빌 때까지 2 반복
- **시간 복잡도**: O(V + E)
- **활용 사례**: 최단 경로 탐색(가중치가 없거나 같은 경우), 레벨 순서 탐색

### 최단 경로 알고리즘

#### 다익스트라 알고리즘(Dijkstra's Algorithm)

- **정의**: 하나의 시작 정점에서 다른 모든 정점까지의 최단 경로를 구하는 알고리즘
- **조건**: 간선의 가중치가 음수가 아닐 때 사용 가능
- **과정**:
  1. 시작 정점의 최단 거리를 0으로, 나머지 정점은 무한대로 초기화
  2. 방문하지 않은 정점 중 최단 거리가 가장 작은 정점 선택
  3. 선택한 정점의 인접 정점들에 대해 최단 거리 갱신
  4. 모든 정점을 방문할 때까지 2-3 반복
- **시간 복잡도**: O(V²) (인접 행렬 사용 시), O(E log V) (우선순위 큐 사용 시)
- **활용 사례**: 네트워크 라우팅, 지도 어플리케이션의 경로 찾기