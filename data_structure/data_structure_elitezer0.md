# 자료구조의 큰 그림

## 자료구조와 알고리즘

### 자료구조

데이터를 효율적으로 저장,  관리, 처리하기 위한 구조
### 알고리즘

문제를 해결하기 위한 절차나 방법을 단계적으로 나열한 것

## 시간 복잡도와 공간 복잡도

### 시간복잡도

입력의 크기에 따른 프로그램 실행 시간의 관계

= 입력의 크기에 따른 프로그램 실행시간

= 입력의 크기에 따른 연산 횟수

#### 빅 오 표기법 (대중적)
- 함수의 점근적 상한을 표기
- 점근적 상한 : 실행 시간이 대략 상한 이상으로는 커지지 않을 것이라는 의미

#### 빅 세타 표기법
- 평균적인 실행 시간
#### 빅 오메가 표기법
- 입력에 대한 실행 시간의 점근적 하한

| 표기법           | 의미                      | 설명                             |
| ------------- | ----------------------- | ------------------------------ |
| **빅-오 (O)**   | **최악의 경우** (상한)         | 성능이 **최대로 얼마나 느려질 수 있는지**를 나타냄 |
| **빅-세타 (Θ)**  | **정확한 성장률** (평균/정확한 경계) | 성능이 정확히 어떤 수준으로 **성장**하는지를 나타냄 |
| **빅-오메가 (Ω)** | **최선의 경우** (하한)         | 성능이 **최소로 얼마나 빨라질 수 있는지**를 나타냄 |
### 공간 복잡도

프로그램이 실행되었을 떄 필요한 메모리 자원의 양

표기법은 주로 빅 오 표기법을 사용

#### 공간 복잡도의 구성 요소

1. **고정 공간 (Fixed Part)** 
    - 변수, 상수, 포인터 등
    - 입력 크기와 무관함 → 예: `int a = 0;`
    
2. **입력에 따른 공간 (Variable Part)**
    - 배열, 재귀 호출 스택, 동적 자료구조 등
    - 입력 크기 nn에 비례하여 증가할 수 있음 → 예: `int[] arr = new int[n];`

#### 시간 복잡도 vs 공간 복잡도

| 항목         | 설명                     |
| ---------- | ---------------------- |
| **시간 복잡도** | 알고리즘이 **걸리는 시간**       |
| **공간 복잡도** | 알고리즘이 **필요로 하는 메모리 양** |

둘은 **트레이드오프** 관계일 수 있음: 공간을 더 써서 시간을 줄이거나, 시간을 더 써서 공간을 아낄 수 있음

- **메모이제이션(Memoization)** → 공간 ↑, 시간 ↓
- **정렬 알고리즘** 중 병합 정렬은 시간 빠름, 공간 많이 씀

### 정렬 알고리즘 복잡도 비교

- **n**: 입력 데이터 개수
- **k**: 값의 범위 (예: 0~1000)
- **안정 정렬**: 같은 값을 가진 원소의 순서를 유지하는 정렬 (예: 병합 정렬, 삽입 정렬 등)

| 알고리즘      | 최선 (Ω)    | 평균 (Θ)    | 최악 (O)    | 공간 복잡도   | 특징                      |
| --------- | --------- | --------- | --------- | -------- | ----------------------- |
| **버블 정렬** | O(n)      | O(n^2)    | O(n^2)    | O(1)     | 단순하지만 느림, 거의 정렬된 경우엔 빠름 |
| **선택 정렬** | O(n^2)    | O(n^2)    | O(n^2)    | O(1)     | 언제나 일정한 성능, 안정성 없음      |
| **삽입 정렬** | O(n)      | O(n^2)    | O(n^2)    | O(1)     | 거의 정렬된 경우 매우 효율적        |
| **병합 정렬** | O(nlog n) | O(nlog⁡n) | O(nlog⁡n) | O(n)     | 안정 정렬, 분할 정복            |
| **퀵 정렬**  | O(nlog⁡n) | O(nlog⁡n) | O(n^2)    | O(log⁡n) | 평균적으로 매우 빠름, 불안정 정렬     |
| **힙 정렬**  | O(nlog⁡n) | O(nlog⁡n) | O(nlog⁡n) | O(1)     | 불안정 정렬, 항상 일정한 성능       |
| **계수 정렬** | O(n+k)    | O(n+k)    | O(n+k)    | O(k)     | 정수(작은 범위) 전용, 매우 빠름     |
| **기수 정렬** | O(nk)     | O(nk)     | O(nk)     | O(n+k)   | 자릿수 기반, 큰 수 정렬 시 유리     |
| **버킷 정렬** | O(n+k)    | O(n+k)    | O(n^2)    | O(n+k)   | 균등 분포일 때 매우 빠름          |

# 배열과 연결 리스트

## 배열

- 같은 자료형의 데이터들을 하나의 연속된 메모리 공간에 저장하는 자료구조
- 0부터 시작하는 인덱스로 빠르게 각 요소에 접근 가능
- 메모리 상에 데이터가 연속적으로 저장
- 생성 시 크기를 정하면 이후 변경 불가(동적 배열 예외)
- 중간에 삽입하거나 삭제하면 요소들을 이동 시켜야 해 삽입/삭제 비용이 큼 → O(n)
	- 파이썬의 배열(list)는 동적 배열이며 다양한 자료형을 혼합해서 저장할 수 있다.

### 시간 복잡도

| 작업          | 시간 복잡도 |
| ----------- | ------ |
| 접근 (Access) | O(1)   |
| 탐색 (Search) | O(n)   |
| 삽입 (Insert) | O(n)   |
| 삭제 (Delete) | O(n)   |

> 단, 배열의 **끝에 추가**할 경우에는 O(1)이 가능

### 확장 개념

| 개념                    | 설명                                           |
| --------------------- | -------------------------------------------- |
| **2차원 배열**            | 표 형태의 데이터 표현 (예: 행렬)                         |
| **동적 배열 (ArrayList)** | 크기 조절 가능한 배열 (자바에서 `ArrayList` c++ `vector`) |
| **다차원 배열**            | 배열 안에 배열이 있는 구조 (예: 3차원 이상)                  |

## 연결 리스트

- 데이터들을 순차적으로 연결한 자료구조
- 각 데이터가 노드(Node)라는 단위로 저장
- 각 노드는 데이터와 다음 노드를 가리키는 포인터(또는 참조)를 가지고 있음.

### 연결 리스트의 기본 구조

```
head → [데이터 | 포인터] → [데이터 | 포인터] → [데이터 | None] ← tail
```

- 각 `[ ]`는 하나의 노드(Node)
- 포인터는 다음 노드의 주소 또는 참조값
- head(헤드 노드)는 연결 리스트의 시작점을 가리키는 포인터이며, 이 노드부터 리스트 탐색이 시작
- tail(꼬리 노드)는 연결 리스트의 마지막 노드로, 이 노드의 포인터는 `null` 또는 `None`을 가리킴
- 마지막 노드(tail)는 더 이상 연결된 노드가 없음을 의미하므로 연결 리스트의 끝

### 연결 리스트의 시간 복잡도

|연산|시간 복잡도|
|---|---|
|접근 (Access)|O(n)O(n)|
|탐색 (Search)|O(n)O(n)|
|삽입 (Insert)|O(1)O(1) (앞에 삽입 시)|
|삭제 (Delete)|O(1)O(1) (앞에서 삭제 시)|

### 연결 리스트의 종류

| 종류                                   | 설명                        |
| ------------------------------------ | ------------------------- |
| **단일 연결 리스트 (Singly Linked List)**   | 노드가 한 방향(다음 노드)으로만 연결     |
| **이중 연결 리스트 (Doubly Linked List)**   | 앞/뒤 양쪽 노드를 가리키는 포인터를 가짐   |
| **환형 연결 리스트 (Circular Linked List)** | 마지막 노드가 첫 노드를 가리킴 (순환 구조) |

### 연결 리스트 vs 배열

|항목|배열 (Array)|연결 리스트 (Linked List)|
|---|---|---|
|메모리 구조|연속적|비연속적 (동적 할당)|
|접근 속도|빠름 O(1)O(1)|느림 O(n)O(n)|
|삽입/삭제|느림 O(n)O(n)|빠름 O(1)O(1) (앞에서)|
|크기 변경|불가능 (정적)|가능 (동적)|

# 스택과 큐

## 스택

- 스택은 데이터를 일시적으로 저장하는 선형 자료구조
- "Last In, First Out" (LIFO, 후입선출) 방식

### 스택 구조

```
┌────────────┐
│    top     │ ← 마지막에 추가된 요소
├────────────┤
│            │
│            │
│            │
└────────────┘
```

- 스택은 한 쪽 끝(top)에서만 데이터를 넣고(push), 빼는(pop) 구조

### 주요 연산

1. `push(value)` – 삽입
	- 스택의 맨 위에 새로운 데이터를 추가
	- 시간 복잡도: O(1)
2. `pop()` – 삭제
	- 스택의 맨 위(top)에 있는 데이터를 제거하고 반환
	- 시간 복잡도: O(1)

#### 그 외 연산

| 연산                  | 설명                  |
| ------------------- | ------------------- |
| `peek()` 또는 `top()` | 스택 맨 위의 값 조회 (삭제 X) |
| `isEmpty()`         | 스택이 비어 있는지 확인       |
| `size()`            | 스택에 들어 있는 요소 수      |

### 스택 활용

| 활용           | 설명                   |
| ------------ | -------------------- |
| 웹 브라우저 뒤로 가기 | 이전 페이지를 스택에 저장하고 pop |
| 괄호 검사        | 열고 닫는 괄호의 쌍 확인       |
| 재귀 호출 처리     | 함수 호출 스택             |
| 후위 표기식 계산    | 계산 순서 유지             |

## 큐

- 먼저 들어온 데이터가 먼저 나가는 선형 자료구조
- First In, First Out (FIFO, 선입선출) 방식
### 큐 구조

```
[front] → 데이터 → 데이터 → 데이터 → [rear]
```

- `enqueue`: 뒤(rear)에서 데이터를 넣음
- `dequeue`: 앞(front)에서 데이터를 뺌

### 주요 연산

1. `enqueue(value)` – 삽입
	- 큐의 뒤쪽(rear)에 데이터를 추가
	- 시간 복잡도: O(1)

 2. `dequeue()` – 삭제
	- 큐의 앞쪽(front) 데이터를 제거하고 반환    
	- 시간 복잡도: O(1)

### 큐 활용

|활용|설명|
|---|---|
|**프린터 대기열**|먼저 요청한 인쇄 작업부터 실행|
|**CPU 작업 스케줄링**|프로세스를 순서대로 처리|
|**그래프 탐색 (BFS)**|너비 우선 탐색에서 큐 사용|
|**네트워크 요청 처리**|순차적 요청 처리 구조|

### 🔄 큐 vs 스택

|항목|큐 (Queue)|스택 (Stack)|
|---|---|---|
|순서|선입선출(FIFO)|후입선출(LIFO)|
|삽입|뒤에서 (rear)|위에 (top)|
|삭제|앞에서 (front)|위에서 (top)|

### 확장 개념
#### 1. 원형 큐 (Circular Queue)

- 큐의 맨 뒤가 다시 맨 앞으로 이어지는 구조
- 고정된 크기의 배열로 큐를 구현할 때, 공간을 효율적으로 재사용하기 위해 사용

```
배열: [3][4][ ][ ][1][2]   ← 배열 길이 5
       ↑     ↑
     rear   front
```

- 원형 큐는 인덱스를 원형처럼 돌려서 빈 공간을 활용
- 메모리 낭비 방지 (고정 크기 배열 사용 시) 
- 선형 큐보다 공간 활용도 높음
- `front == rear`일 때가 **비어 있음인지, 꽉 찬 것인지** 구분 필요  
    → 보통 한 칸 비워두거나, `size` 변수 사용

#### 2. 우선순위 큐 (Priority Queue)

- 들어온 순서와 관계없이 우선순위(priority)가 높은 요소가 먼저 나감
- 우선순위 큐는 내부적으로 힙(Heap) 자료구조를 사용함
- 작업 스케줄링, 이벤트 처리, 다익스트라 최단경로 등에 사용

#### 3. 양방향 큐 (Deque: Double-Ended Queue)

- 큐의 양 끝(front와 rear) 모두에서 삽입/삭제가 가능한 자료구조
- 큐 + 스택 기능을 모두 수행
- 회문(팰린드롬) 검사, 슬라이딩 윈도우 최댓값 알고리즘 등에 유용

|연산|설명|
|---|---|
|`append()`|뒤쪽(rear)에 삽입|
|`appendleft()`|앞쪽(front)에 삽입|
|`pop()`|뒤쪽에서 제거|
|`popleft()`|앞쪽에서 제거|

#### 비교

| 구조                | 삽입 위치        | 삭제 위치        | 특징                  |
| ----------------- | ------------ | ------------ | ------------------- |
| **원형 큐**          | rear         | front        | 공간 효율적 재사용          |
| **우선순위 큐**        | 우선순위 기반 정렬   | 우선순위 가장 높은 곳 | 힙으로 구현, 다익스트라 등에 사용 |
| **양방향 큐 (Deque)** | front + rear | front + rear | 유연한 큐/스택 기능         |

# 해시 테이블

- 데이터를 저장할 때,  키(key)를 해시 함수(hash function)에 넣어 배열의 인덱스(index)로 변환하고,  
그 위치에 값을 저장하는 구조

### 구조

```
Key         →    Hash Function    →     Index
"apple"     →    hash("apple")    →     3

Hash Table:  [ , , , ("apple", 100), , , ]
```

- `"apple"`이라는 키를 해시 함수에 넣으면 `3`이라는 인덱스가 나옴
- 해시 테이블은 이 인덱스에 값을 저장함 → 조회 시에도 동일한 방식으로 접근

### 주요 연산

| 연산                | 설명         | 시간 복잡도  |
| ----------------- | ---------- | ------- |
| `put(key, value)` | 키-값 저장     | 평균 O(1) |
| `get(key)`        | 키를 통한 값 조회 | 평균 O(1) |
| `remove(key)`     | 키-값 삭제     | 평균 O(1) |

※ **최악의 경우 O(n)** (해시 충돌이 모두 발생할 경우)

### 해시 충돌(Collision)

두 개 이상의 키가 같은 인덱스로 해시될 경우 → 충돌 발생
#### 해결 방법

|방법|설명|
|---|---|
|**체이닝(Chaining)**|같은 인덱스에 연결 리스트로 여러 값 저장|
|**개방 주소법(Open Addressing)**|비어있는 다음 공간을 찾아 저장 (선형 탐사, 이차 탐사 등)|

### 해시 테이블 활용

| 활용 분야      | 설명                     |
| ---------- | ---------------------- |
| 데이터베이스 인덱스 | 빠른 키-값 검색              |
| 캐시(Cache)  | 최근 사용한 데이터 저장          |
| 중복 체크      | 중복 원소 판별               |
| 집합 연산      | 집합 포함 여부 확인 (예: `set`) |

### 해시 함수(Hash Function)

임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 변환하는 단방향 함수

= 긴 데이터를 짧은 숫자/문자열로 바꿔주는 일종의 요약기계

#### 해시 알고리즘의 역할

1. 데이터 저장용 주소 계산 (예: 해시 테이블에서 key → index)
2. 비밀번호 암호화
3. 파일 무결성 검사 (변조 여부 확인)
4. 디지털 서명 및 인증

|조건|설명|
|---|---|
|**빠름**|계산 속도가 빨라야 함|
|**균일한 분포**|해시값이 고르게 퍼져야 충돌 감소|
|**결정적**|같은 입력엔 항상 같은 출력|

#### 해시 알고리즘의 특징 (암호학적 기준)

|특징|설명|
|---|---|
|**단방향성**|결과값(해시)만 보고 원래 입력을 알아내는 것이 매우 어려움|
|**충돌 회피성**|서로 다른 입력이 같은 해시 값을 만들 확률이 매우 낮음|
|**고정 길이 출력**|입력 크기에 상관없이 항상 일정한 길이의 해시값 출력|
|**빠른 계산 속도**|입력에 대해 빠르게 결과를 계산할 수 있음|
|**작은 변화 → 큰 차이**|입력값의 1비트만 바뀌어도 완전히 다른 해시 출력이 나옴 (Avalanche Effect)|

#### 대표적인 해시 알고리즘 종류

|알고리즘|출력 길이|특징|
|---|---|---|
|**MD5**|128비트 (16바이트)|빠르지만 보안에 취약 (충돌 있음)|
|**SHA-1**|160비트 (20바이트)|보안상 더 이상 권장되지 않음|
|**SHA-256**|256비트 (32바이트)|현재 가장 널리 사용되는 안전한 해시|
|**SHA-3**|224~512비트|SHA-2의 대체로 제안된 새로운 해시 표준|
|**BLAKE2**|256~512비트|빠르고 안전함, 현대적 대안|

#### 실생활 예

- **비밀번호 저장**: 실제 비밀번호를 저장하지 않고 해시만 저장
- **파일 검증**: 다운로드 파일의 해시와 비교하여 손상 여부 확인
- **Git**: 커밋 해시를 사용해 버전 추적
- **블록체인**: 블록의 고유 식별자로 해시 사용
