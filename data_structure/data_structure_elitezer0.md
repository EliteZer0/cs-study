# 자료구조의 큰 그림

## 자료구조와 알고리즘

### 자료구조

데이터를 효율적으로 저장,  관리, 처리하기 위한 구조
### 알고리즘

문제를 해결하기 위한 절차나 방법을 단계적으로 나열한 것

## 시간 복잡도와 공간 복잡도

### 시간복잡도

입력의 크기에 따른 프로그램 실행 시간의 관계

= 입력의 크기에 따른 프로그램 실행시간

= 입력의 크기에 따른 연산 횟수

#### 빅 오 표기법 (대중적)
- 함수의 점근적 상한을 표기
- 점근적 상한 : 실행 시간이 대략 상한 이상으로는 커지지 않을 것이라는 의미

#### 빅 세타 표기법
- 평균적인 실행 시간
#### 빅 오메가 표기법
- 입력에 대한 실행 시간의 점근적 하한

| 표기법           | 의미                      | 설명                             |
| ------------- | ----------------------- | ------------------------------ |
| **빅-오 (O)**   | **최악의 경우** (상한)         | 성능이 **최대로 얼마나 느려질 수 있는지**를 나타냄 |
| **빅-세타 (Θ)**  | **정확한 성장률** (평균/정확한 경계) | 성능이 정확히 어떤 수준으로 **성장**하는지를 나타냄 |
| **빅-오메가 (Ω)** | **최선의 경우** (하한)         | 성능이 **최소로 얼마나 빨라질 수 있는지**를 나타냄 |
### 공간 복잡도

프로그램이 실행되었을 떄 필요한 메모리 자원의 양

표기법은 주로 빅 오 표기법을 사용

#### 공간 복잡도의 구성 요소

1. **고정 공간 (Fixed Part)** 
    - 변수, 상수, 포인터 등
    - 입력 크기와 무관함 → 예: `int a = 0;`
    
2. **입력에 따른 공간 (Variable Part)**
    - 배열, 재귀 호출 스택, 동적 자료구조 등
    - 입력 크기 nn에 비례하여 증가할 수 있음 → 예: `int[] arr = new int[n];`

#### 시간 복잡도 vs 공간 복잡도

| 항목         | 설명                     |
| ---------- | ---------------------- |
| **시간 복잡도** | 알고리즘이 **걸리는 시간**       |
| **공간 복잡도** | 알고리즘이 **필요로 하는 메모리 양** |

둘은 **트레이드오프** 관계일 수 있음: 공간을 더 써서 시간을 줄이거나, 시간을 더 써서 공간을 아낄 수 있음

- **메모이제이션(Memoization)** → 공간 ↑, 시간 ↓
- **정렬 알고리즘** 중 병합 정렬은 시간 빠름, 공간 많이 씀

### 정렬 알고리즘 복잡도 비교

- **n**: 입력 데이터 개수
- **k**: 값의 범위 (예: 0~1000)
- **안정 정렬**: 같은 값을 가진 원소의 순서를 유지하는 정렬 (예: 병합 정렬, 삽입 정렬 등)

| 알고리즘      | 최선 (Ω)    | 평균 (Θ)    | 최악 (O)    | 공간 복잡도   | 특징                      |
| --------- | --------- | --------- | --------- | -------- | ----------------------- |
| **버블 정렬** | O(n)      | O(n^2)    | O(n^2)    | O(1)     | 단순하지만 느림, 거의 정렬된 경우엔 빠름 |
| **선택 정렬** | O(n^2)    | O(n^2)    | O(n^2)    | O(1)     | 언제나 일정한 성능, 안정성 없음      |
| **삽입 정렬** | O(n)      | O(n^2)    | O(n^2)    | O(1)     | 거의 정렬된 경우 매우 효율적        |
| **병합 정렬** | O(nlog n) | O(nlog⁡n) | O(nlog⁡n) | O(n)     | 안정 정렬, 분할 정복            |
| **퀵 정렬**  | O(nlog⁡n) | O(nlog⁡n) | O(n^2)    | O(log⁡n) | 평균적으로 매우 빠름, 불안정 정렬     |
| **힙 정렬**  | O(nlog⁡n) | O(nlog⁡n) | O(nlog⁡n) | O(1)     | 불안정 정렬, 항상 일정한 성능       |
| **계수 정렬** | O(n+k)    | O(n+k)    | O(n+k)    | O(k)     | 정수(작은 범위) 전용, 매우 빠름     |
| **기수 정렬** | O(nk)     | O(nk)     | O(nk)     | O(n+k)   | 자릿수 기반, 큰 수 정렬 시 유리     |
| **버킷 정렬** | O(n+k)    | O(n+k)    | O(n^2)    | O(n+k)   | 균등 분포일 때 매우 빠름          |

# 배열과 연결 리스트

## 배열

- 같은 자료형의 데이터들을 하나의 연속된 메모리 공간에 저장하는 자료구조
- 0부터 시작하는 인덱스로 빠르게 각 요소에 접근 가능
- 메모리 상에 데이터가 연속적으로 저장
- 생성 시 크기를 정하면 이후 변경 불가(동적 배열 예외)
- 중간에 삽입하거나 삭제하면 요소들을 이동 시켜야 해 삽입/삭제 비용이 큼 → O(n)
	- 파이썬의 배열(list)는 동적 배열이며 다양한 자료형을 혼합해서 저장할 수 있다.

### 시간 복잡도

| 작업          | 시간 복잡도 |
| ----------- | ------ |
| 접근 (Access) | O(1)   |
| 탐색 (Search) | O(n)   |
| 삽입 (Insert) | O(n)   |
| 삭제 (Delete) | O(n)   |

> 단, 배열의 **끝에 추가**할 경우에는 O(1)이 가능

### 확장 개념

| 개념                    | 설명                                           |
| --------------------- | -------------------------------------------- |
| **2차원 배열**            | 표 형태의 데이터 표현 (예: 행렬)                         |
| **동적 배열 (ArrayList)** | 크기 조절 가능한 배열 (자바에서 `ArrayList` c++ `vector`) |
| **다차원 배열**            | 배열 안에 배열이 있는 구조 (예: 3차원 이상)                  |

## 연결 리스트

- 데이터들을 순차적으로 연결한 자료구조
- 각 데이터가 노드(Node)라는 단위로 저장
- 각 노드는 데이터와 다음 노드를 가리키는 포인터(또는 참조)를 가지고 있음.

### 연결 리스트의 기본 구조

```
head → [데이터 | 포인터] → [데이터 | 포인터] → [데이터 | None] ← tail
```

- 각 `[ ]`는 하나의 노드(Node)
- 포인터는 다음 노드의 주소 또는 참조값
- head(헤드 노드)는 연결 리스트의 시작점을 가리키는 포인터이며, 이 노드부터 리스트 탐색이 시작
- tail(꼬리 노드)는 연결 리스트의 마지막 노드로, 이 노드의 포인터는 `null` 또는 `None`을 가리킴
- 마지막 노드(tail)는 더 이상 연결된 노드가 없음을 의미하므로 연결 리스트의 끝

### 연결 리스트의 시간 복잡도

|연산|시간 복잡도|
|---|---|
|접근 (Access)|O(n)O(n)|
|탐색 (Search)|O(n)O(n)|
|삽입 (Insert)|O(1)O(1) (앞에 삽입 시)|
|삭제 (Delete)|O(1)O(1) (앞에서 삭제 시)|

### 연결 리스트의 종류

| 종류                                   | 설명                        |
| ------------------------------------ | ------------------------- |
| **단일 연결 리스트 (Singly Linked List)**   | 노드가 한 방향(다음 노드)으로만 연결     |
| **이중 연결 리스트 (Doubly Linked List)**   | 앞/뒤 양쪽 노드를 가리키는 포인터를 가짐   |
| **환형 연결 리스트 (Circular Linked List)** | 마지막 노드가 첫 노드를 가리킴 (순환 구조) |

### 연결 리스트 vs 배열

|항목|배열 (Array)|연결 리스트 (Linked List)|
|---|---|---|
|메모리 구조|연속적|비연속적 (동적 할당)|
|접근 속도|빠름 O(1)O(1)|느림 O(n)O(n)|
|삽입/삭제|느림 O(n)O(n)|빠름 O(1)O(1) (앞에서)|
|크기 변경|불가능 (정적)|가능 (동적)|

# 스택과 큐

## 스택

- 스택은 데이터를 일시적으로 저장하는 선형 자료구조
- "Last In, First Out" (LIFO, 후입선출) 방식

### 스택 구조

```
┌────────────┐
│    top     │ ← 마지막에 추가된 요소
├────────────┤
│            │
│            │
│            │
└────────────┘
```

- 스택은 한 쪽 끝(top)에서만 데이터를 넣고(push), 빼는(pop) 구조

### 주요 연산

1. `push(value)` – 삽입
	- 스택의 맨 위에 새로운 데이터를 추가
	- 시간 복잡도: O(1)
2. `pop()` – 삭제
	- 스택의 맨 위(top)에 있는 데이터를 제거하고 반환
	- 시간 복잡도: O(1)

#### 그 외 연산

| 연산                  | 설명                  |
| ------------------- | ------------------- |
| `peek()` 또는 `top()` | 스택 맨 위의 값 조회 (삭제 X) |
| `isEmpty()`         | 스택이 비어 있는지 확인       |
| `size()`            | 스택에 들어 있는 요소 수      |

### 스택 활용

| 활용           | 설명                   |
| ------------ | -------------------- |
| 웹 브라우저 뒤로 가기 | 이전 페이지를 스택에 저장하고 pop |
| 괄호 검사        | 열고 닫는 괄호의 쌍 확인       |
| 재귀 호출 처리     | 함수 호출 스택             |
| 후위 표기식 계산    | 계산 순서 유지             |

## 큐

- 먼저 들어온 데이터가 먼저 나가는 선형 자료구조
- First In, First Out (FIFO, 선입선출) 방식
### 큐 구조

```
[front] → 데이터 → 데이터 → 데이터 → [rear]
```

- `enqueue`: 뒤(rear)에서 데이터를 넣음
- `dequeue`: 앞(front)에서 데이터를 뺌

### 주요 연산

1. `enqueue(value)` – 삽입
	- 큐의 뒤쪽(rear)에 데이터를 추가
	- 시간 복잡도: O(1)

 2. `dequeue()` – 삭제
	- 큐의 앞쪽(front) 데이터를 제거하고 반환    
	- 시간 복잡도: O(1)

### 큐 활용

|활용|설명|
|---|---|
|**프린터 대기열**|먼저 요청한 인쇄 작업부터 실행|
|**CPU 작업 스케줄링**|프로세스를 순서대로 처리|
|**그래프 탐색 (BFS)**|너비 우선 탐색에서 큐 사용|
|**네트워크 요청 처리**|순차적 요청 처리 구조|

### 🔄 큐 vs 스택

|항목|큐 (Queue)|스택 (Stack)|
|---|---|---|
|순서|선입선출(FIFO)|후입선출(LIFO)|
|삽입|뒤에서 (rear)|위에 (top)|
|삭제|앞에서 (front)|위에서 (top)|

### 확장 개념
#### 1. 원형 큐 (Circular Queue)

- 큐의 맨 뒤가 다시 맨 앞으로 이어지는 구조
- 고정된 크기의 배열로 큐를 구현할 때, 공간을 효율적으로 재사용하기 위해 사용

```
배열: [3][4][ ][ ][1][2]   ← 배열 길이 5
       ↑     ↑
     rear   front
```

- 원형 큐는 인덱스를 원형처럼 돌려서 빈 공간을 활용
- 메모리 낭비 방지 (고정 크기 배열 사용 시) 
- 선형 큐보다 공간 활용도 높음
- `front == rear`일 때가 **비어 있음인지, 꽉 찬 것인지** 구분 필요  
    → 보통 한 칸 비워두거나, `size` 변수 사용

#### 2. 우선순위 큐 (Priority Queue)

- 들어온 순서와 관계없이 우선순위(priority)가 높은 요소가 먼저 나감
- 우선순위 큐는 내부적으로 힙(Heap) 자료구조를 사용함
- 작업 스케줄링, 이벤트 처리, 다익스트라 최단경로 등에 사용

#### 3. 양방향 큐 (Deque: Double-Ended Queue)

- 큐의 양 끝(front와 rear) 모두에서 삽입/삭제가 가능한 자료구조
- 큐 + 스택 기능을 모두 수행
- 회문(팰린드롬) 검사, 슬라이딩 윈도우 최댓값 알고리즘 등에 유용

|연산|설명|
|---|---|
|`append()`|뒤쪽(rear)에 삽입|
|`appendleft()`|앞쪽(front)에 삽입|
|`pop()`|뒤쪽에서 제거|
|`popleft()`|앞쪽에서 제거|

#### 비교

| 구조                | 삽입 위치        | 삭제 위치        | 특징                  |
| ----------------- | ------------ | ------------ | ------------------- |
| **원형 큐**          | rear         | front        | 공간 효율적 재사용          |
| **우선순위 큐**        | 우선순위 기반 정렬   | 우선순위 가장 높은 곳 | 힙으로 구현, 다익스트라 등에 사용 |
| **양방향 큐 (Deque)** | front + rear | front + rear | 유연한 큐/스택 기능         |

# 해시 테이블

- 데이터를 저장할 때,  키(key)를 해시 함수(hash function)에 넣어 배열의 인덱스(index)로 변환하고,  
그 위치에 값을 저장하는 구조

### 구조

```
Key         →    Hash Function    →     Index
"apple"     →    hash("apple")    →     3

Hash Table:  [ , , , ("apple", 100), , , ]
```

- `"apple"`이라는 키를 해시 함수에 넣으면 `3`이라는 인덱스가 나옴
- 해시 테이블은 이 인덱스에 값을 저장함 → 조회 시에도 동일한 방식으로 접근

### 주요 연산

| 연산                | 설명         | 시간 복잡도  |
| ----------------- | ---------- | ------- |
| `put(key, value)` | 키-값 저장     | 평균 O(1) |
| `get(key)`        | 키를 통한 값 조회 | 평균 O(1) |
| `remove(key)`     | 키-값 삭제     | 평균 O(1) |

※ **최악의 경우 O(n)** (해시 충돌이 모두 발생할 경우)

### 해시 충돌(Collision)

두 개 이상의 키가 같은 인덱스로 해시될 경우 → 충돌 발생
#### 해결 방법

|방법|설명|
|---|---|
|**체이닝(Chaining)**|같은 인덱스에 연결 리스트로 여러 값 저장|
|**개방 주소법(Open Addressing)**|비어있는 다음 공간을 찾아 저장 (선형 탐사, 이차 탐사 등)|

### 해시 테이블 활용

| 활용 분야      | 설명                     |
| ---------- | ---------------------- |
| 데이터베이스 인덱스 | 빠른 키-값 검색              |
| 캐시(Cache)  | 최근 사용한 데이터 저장          |
| 중복 체크      | 중복 원소 판별               |
| 집합 연산      | 집합 포함 여부 확인 (예: `set`) |

### 해시 함수(Hash Function)

임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 변환하는 단방향 함수

= 긴 데이터를 짧은 숫자/문자열로 바꿔주는 일종의 요약기계

#### 해시 알고리즘의 역할

1. 데이터 저장용 주소 계산 (예: 해시 테이블에서 key → index)
2. 비밀번호 암호화
3. 파일 무결성 검사 (변조 여부 확인)
4. 디지털 서명 및 인증

|조건|설명|
|---|---|
|**빠름**|계산 속도가 빨라야 함|
|**균일한 분포**|해시값이 고르게 퍼져야 충돌 감소|
|**결정적**|같은 입력엔 항상 같은 출력|

#### 해시 알고리즘의 특징 (암호학적 기준)

|특징|설명|
|---|---|
|**단방향성**|결과값(해시)만 보고 원래 입력을 알아내는 것이 매우 어려움|
|**충돌 회피성**|서로 다른 입력이 같은 해시 값을 만들 확률이 매우 낮음|
|**고정 길이 출력**|입력 크기에 상관없이 항상 일정한 길이의 해시값 출력|
|**빠른 계산 속도**|입력에 대해 빠르게 결과를 계산할 수 있음|
|**작은 변화 → 큰 차이**|입력값의 1비트만 바뀌어도 완전히 다른 해시 출력이 나옴 (Avalanche Effect)|

#### 대표적인 해시 알고리즘 종류

|알고리즘|출력 길이|특징|
|---|---|---|
|**MD5**|128비트 (16바이트)|빠르지만 보안에 취약 (충돌 있음)|
|**SHA-1**|160비트 (20바이트)|보안상 더 이상 권장되지 않음|
|**SHA-256**|256비트 (32바이트)|현재 가장 널리 사용되는 안전한 해시|
|**SHA-3**|224~512비트|SHA-2의 대체로 제안된 새로운 해시 표준|
|**BLAKE2**|256~512비트|빠르고 안전함, 현대적 대안|

#### 실생활 예

- **비밀번호 저장**: 실제 비밀번호를 저장하지 않고 해시만 저장
- **파일 검증**: 다운로드 파일의 해시와 비교하여 손상 여부 확인
- **Git**: 커밋 해시를 사용해 버전 추적
- **블록체인**: 블록의 고유 식별자로 해시 사용

# 트리

트리는 노드(Node)와 간선(Edge)으로 구성된 자료구조
사이클이 없는 계층적 구조의 그래프
## 트리의 구성 요소

### 1. 노드(Node)

- 트리의 **데이터 단위**
- 각 노드는 데이터 + 자식 노드의 링크(포인터)를 가짐

### 2. 간선(Edge)

- 노드와 노드를 연결하는 선
- 간선의 수 = 노드 수 - 1 (트리는 항상 이 공식을 만족)

### 3. 루트 노드(Root Node)

- 트리의 **시작점**, 부모가 없는 유일한 노드

### 4. 자식 노드(Child Node)

- 어떤 노드의 하위 노드

### 5. 부모 노드(Parent Node)

- 어떤 노드를 가리키는 상위 노드

### 6. 형제 노드(Sibling Node)

- 같은 부모를 가진 노드들

### 7. 리프 노드(Leaf Node)

- **자식이 없는 노드**, 끝점 노드

### 8. 차수

- **하나의 노드가 가지고 있는 자식 노드의 수**
- 예:
    - 자식이 2개 → 차수 2   
    - 리프 노드 → 자식이 없으므로 차수 0
- 트리의 차수 : 트리에 있는 **노드들 중에서 가장 큰 차수값**

### 9. 레벨(Level)

- 루트 노드에서 시작해 특정 노드에 이르기까지 거치게 되는 간선의 수
- 트리에서 **루트는 레벨 0**, 아래로 한 단계씩 내려갈 때마다 레벨 1 증가
- 이는 Depth와 같은 개념

### 10. 높이(Height)

- 리프 노드까지의 **최대 깊이**
## 서브트리 (Subtree)

- **어떤 노드를 루트로 하는 하위 트리 전체**
- 트리는 **재귀적인 구조**이기 때문에, **각 노드 자체도 하나의 트리로 간주**할 수 있다.
    

```plaintext
        A
       / \
      B   C
     / \   \
    D   E   F
```

- **B의 서브트리**:
    
    ```
        B
       / \
      D   E
    ```
    
- **C의 서브트리**:
    
    ```
      C
       \
        F
    ```
    
- 서브트리 역시 **트리의 모든 정의(노드, 간선, 루트 등)를 만족**
- **루트 노드로부터 특정 노드를 제거하고 나머지를 별도로 떼면 그것도 하나의 서브트리**

## 특징

| 항목                   | 설명                  |
| -------------------- | ------------------- |
| **비선형 구조**           | 배열이나 리스트와 달리 계층적 관계 |
| **사이클 없음**           | 루프가 존재하지 않음         |
| **1개의 루트 노드**        | 모든 트리는 하나의 시작점을 가짐  |
| **n개의 노드는 n-1개의 간선** | 항상 만족하는 수학적 특징      |

## 트리 순회

트리 순회(Tree Traversal)는 트리 구조의 노드를 특정한 순서로 방문(탐색)하는 방법

트리 순회는 크게 **두 가지 방식**

1. **깊이 우선 순회 (DFS - Depth First Search)**
    - 전위 순회 (Preorder)
    - 중위 순회 (Inorder)
    - 후위 순회 (Postorder)
        
2. **너비 우선 순회 (BFS - Breadth First Search)**
    - 레벨 순서대로 방문 (Level-order)

### 깊이 우선 순회 (DFS)

```
        A
       / \
      B   C
     / \   \
    D   E   F
```

#### 전위 순회 (Preorder)

> 순서: **부모 → 왼쪽 → 오른쪽**

```plaintext
visit(node)
traverse(node.left)
traverse(node.right)
```

예시 결과: `A B D E C F`

#### 중위 순회 (Inorder)

> 순서: **왼쪽 → 부모 → 오른쪽**  
> 이진 탐색 트리(BST)에서 **중위 순회하면 오름차순 정렬된 값**이 나옵니다.

```plaintext
traverse(node.left)
visit(node)
traverse(node.right)
```

예시 결과: `D B E A C F`

#### 후위 순회 (Postorder)

> 순서: **왼쪽 → 오른쪽 → 부모**

```plaintext
traverse(node.left)
traverse(node.right)
visit(node)
```

예시 결과: `D E B F C A`

### 너비 우선 순회 (Level-order, BFS)

> 순서: **루트 → 같은 레벨의 왼쪽에서 오른쪽으로**

- 큐(Queue)를 사용해 구현
- 예시 결과: `A B C D E F`
   
### 요약

|순회 방식|순서|주요 특징|
|---|---|---|
|**전위(Preorder)**|루트 → 왼쪽 → 오른쪽|트리 복사|
|**중위(Inorder)**|왼쪽 → 루트 → 오른쪽|BST에서 정렬 결과|
|**후위(Postorder)**|왼쪽 → 오른쪽 → 루트|트리 삭제|
|**레벨(Level-order)**|위에서 아래, 왼쪽 → 오른쪽|BFS, 큐 사용|

## 종류

### **이진 트리**

|트리 종류|설명|
|---|---|
|**이진 트리**|노드당 자식이 **최대 2개**인 트리|
|**편향된 이진 트리**|모든 노드가 **한쪽(왼쪽 또는 오른쪽)** 자식만 가짐 → **선형 구조처럼 됨**|
|**정 이진 트리 (Proper Binary Tree)**|모든 노드가 **자식이 0개(리프) 또는 2개**|
|**포화 이진 트리 (Full Binary Tree)**|**모든 노드가 자식 0개 또는 2개이고**, **리프는 같은 깊이**에 존재|
|**완전 이진 트리 (Complete Binary Tree)**|**왼쪽부터 빈틈 없이 채워진 이진 트리** (마지막 레벨 제외)|
|**이진 탐색 트리 (BST)**|왼쪽 자식 < 루트 < 오른쪽 자식, 정렬 구조|
|**힙(Heap)**|완전 이진 트리 기반. 루트는 **최댓값(최대 힙)** 또는 **최솟값(최소 힙)** 유지|

### **자가 균형 이진 탐색 트리 (Self-balancing BST)**

| 트리 종류                    | 설명                                                      |
| ------------------------ | ------------------------------------------------------- |
| **AVL 트리**               | 삽입/삭제 후 **높이 균형**을 유지 (노드 간 높이 차이 ≤ 1), 회전(Rotation) 사용 |
| **Red-Black 트리 (RB 트리)** | 노드를 **빨강/검정 색**으로 표시하며 균형 유지, 연산 속도 빠르고 구현 간단           |
| **NIL 노드**               | RB 트리에서 사용되는 **가상(검정색) 리프 노드**, 균형 계산과 로직 단순화에 도움       |

### **다진 트리 / 디스크 기반 트리**

|트리 종류|설명|
|---|---|
|**B-트리**|자식 수가 많은 **균형 탐색 트리**, **디스크 기반 데이터베이스**에서 사용|
|**B+ 트리**|B-트리의 확장, **리프 노드만 실제 데이터를 저장**, **범위 검색 효율적**|
|사용 예:|파일 시스템, 인덱스(DBMS) 등|

### **특수 목적 트리**

|트리 종류|설명|
|---|---|
|**트라이(Trie)**|문자열 검색 트리, 문자마다 노드 분기, **접두사 검색 및 자동 완성**에 유리|
|**세그먼트 트리 (Segment Tree)**|배열 구간의 합/최솟값/최댓값 등을 빠르게 구간 질의할 수 있게 하는 트리|
|**펜윅 트리 (Fenwick Tree, Binary Indexed Tree)**|세그먼트 트리보다 간단하고 **공간 효율적인 누적합 처리 트리**|

### 요약

|트리 종류|주요 목적 / 용도|
|---|---|
|**이진 트리**|기본 구조|
|**편향 이진 트리**|(비효율적 구조 예시)|
|**정/포화/완전 이진 트리**|이진 트리의 형식 분류|
|**BST**|정렬 + 탐색|
|**AVL / Red-Black**|탐색 성능 유지 위한 균형 BST|
|**Heap**|우선순위 큐, 정렬|
|**B, B+ 트리**|디스크 기반 대규모 데이터 인덱싱|
|**Trie**|문자열 탐색/검색/자동완성|
|**Segment Tree**|구간 쿼리 (합, 최댓값 등)|
|**Fenwick Tree**|누적합 처리 (단일 업데이트, 구간 합 빠름)|

# 그래프

**그래프(Graph)**는 **정점(Vertex)**과 이들을 연결하는 **간선(Edge)**으로 이루어진 **비선형 자료구조**

> 트리는 그래프의 일종이며, **사이클이 없는 연결 그래프**


## 그래프의 기본 구성 요소

|구성 요소|설명|
|---|---|
|**정점(Vertex)**|그래프의 노드 (예: 도시, 사용자, 웹 페이지 등)|
|**간선(Edge)**|정점 간의 연결 관계 (예: 도로, 친구 관계 등)|
|**가중치(Weight)**|간선에 부여된 값 (예: 거리, 비용 등)|
|**방향성(Direction)**|간선이 한쪽 방향인지 양방향인지|

## 그래프의 종류

|분류 기준|종류|설명|
|---|---|---|
|**방향**|**무방향 그래프**|A — B (양방향 연결)|
||**방향 그래프**|A → B (한쪽 방향만 연결)|
|**사이클**|**사이클 그래프**|다시 자기 자신으로 돌아오는 경로 존재|
||**비사이클 그래프**|루프가 없음 (트리 포함)|
|**가중치**|**가중치 그래프**|간선에 거리/비용이 있음|
||**비가중치 그래프**|모든 간선의 값이 동일 또는 없음|
|**연결성**|**연결 그래프**|모든 정점이 연결됨|
||**비연결 그래프**|일부 정점이 고립됨|

## 그래프 표현 방식

### 인접 행렬 (Adjacency Matrix)

- 2차원 배열로 정점 간 연결 유무 표현
- 공간 복잡도: O(V2)O(V^2)

```plaintext
  A B C
A 0 1 1
B 1 0 0
C 1 0 0
```

### 인접 리스트 (Adjacency List)

- 각 정점마다 연결된 정점들을 리스트로 저장
- 공간 효율 좋음: O(V+E)O(V + E)

```python
graph = {
    'A': ['B', 'C'],
    'B': ['A'],
    'C': ['A']
}
```

## 그래프 탐색 알고리즘

|알고리즘|설명|구현 방식|
|---|---|---|
|**DFS** (깊이 우선 탐색)|최대한 깊이 내려가며 방문|재귀 / 스택|
|**BFS** (너비 우선 탐색)|가까운 노드부터 넓게 탐색|큐 사용|

## 그래프 관련 알고리즘

|알고리즘|용도|
|---|---|
|**다익스트라(Dijkstra)**|단일 시작점에서 최단 거리 (가중치 양수)|
|**벨만-포드(Bellman-Ford)**|음수 가중치 허용 단일 최단 경로|
|**플로이드-워셜(Floyd-Warshall)**|모든 쌍 최단 경로 (DP 기반)|
|**크루스칼(Kruskal)**|최소 신장 트리 (MST), 간선 중심|
|**프림(Prim)**|최소 신장 트리, 정점 중심|
|**위상 정렬(Topological Sort)**|방향 비순환 그래프(DAG)의 순서 정렬|
|**유니온 파인드 (Union-Find)**|연결 여부 판단, 사이클 검출, MST|
