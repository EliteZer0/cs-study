# 1. 자료구조의 큰 그림

## 자료구조와 알고리즘

- 자료구조 : 데이터를 효율적으로 저장하고 관리하기 위한 방법
- 알고리즘 : 어떤 목적을 이루기 위해 필요한 일련의 연산 절차

## 시간 복잡도와 공간 복잡도

개발자는 소스 코드를 통해 다양한 데이터를 다루고(자료구조), 특정 목적을 이루기 위한 연산(알고리즘)을 구현한다.

알고리즘과 자료구조를 고려한 코드는 훨씬 더 품질 좋은 코드가 될 가능성이 높다.

이러한 성능 차이를 객관적으로 판단할 수 있는 방법?

시간 복잡도, 공간 복잡도

- **시간 복잡도 (Time Complexity)**

  - 입력 크기에 따른 프로그램 실행 시간의 관계
  - 실행 시간은 연산 횟수에 비례한다고 간주하므로 입력의 크기에 따른 연산 횟수라고 할 수 있다.

- **빅 오 표기법(Big O Notation)**

  - 함수의 점근적 상한을 표기하는 방법
  - 시간 복잡도를 표현할 때 주로 사용.
  - 입력 크기가 무한대로 커질 때 실행 시간의 상한을 나타낸다.
    - 평균적인 실행 시간은 '빅 세타 표기법'을, 입력에 대한 실행 시간의 점근적 하한은 '빅 오메가 표기법'으로 나타낸다.
  - 계수와 낮은 차수의 항은 무시하고 최고차항의 차수만 고려.

- **공간 복잡도(Space Complexity)**

  - 프로그램이 실행되었을 때 필요한 메모리 자원의 양
  - 입력에 따른 메모리 사용량의 척도
  - 빅 오 표기법으로 표현하기도 하지만, 빅 오 표기법은 대부분 시간 복잡도인 경우가 많음에 유의하자.

## 2. 배열과 연결 리스트

### 배열

- 메모리에 순차적으로 저장된 같은 타입의 변수 집합
- 0부터 시작하는 고유한 순서 번호인 인덱스(index)로 배열의 요소를 식별한다.
- 정적 배열(static array)일 경우 크기가 고정되고, 동적 배열(dynamic array)일 경우 개수가 동적으로 변한다.(C++일 경우 vector으로 사용(std::vector<T>))

- **연산의 시간 복잡도**:

  - 접근: O(1)
  - 검색: O(n)
  - 삽입: O(n)
  - 삭제: O(n)

### 연결 리스트

- 노드의 모음으로 구성된 자료구조
- 각 노드는 데이터와 다음 노드를 가리키는 포인터로 구성
- 연속적으로 구성되어 있는 데이터를 불연속적으로 저장 할 때 유용하게 사용할 수 있다.
- 연결 리스트의 종류:

  - 단일 연결 리스트(Singly Linked List)
    - 각 노드가 다음 노드의 위치 정보만 가지고 있음
  - 이중 연결 리스트(Doubly Linked List)
    - 각 노드가 이전 노드와 다음 노드 둘의 위치 정보를 가지고 있음
  - 환형 연결 리스트(Circular Linked List)
    - 마지막 노드가 첫 번째 노드의 위치 정보를 가지고 있음

- **연산의 시간 복잡도**:

  - 접근: O(n)
  - 검색: O(n)
  - 삽입: O(1)
  - 삭제: O(1)

## 3. 스택과 큐

### 스택

- 한 쪽에서만 데이터의 삽입 및 삭제가 가능한 자료구조
- 후입선출(LIFO(Last In First Out)) 자료구조라고 이야기하기도 한다.
- 함수의 매개변수를 저장하고 사용하기 위해, 웹 브라우저의 뒤로가기 기능 등에 쓰인다.

- **주요 연산 및 시간 복잡도(Java, LinkedList 기준)**

  - Push: 스택의 맨 위에 요소 추가, O(1)
  - Pop: 스택의 맨 위 요소 제거 및 반환, O(1)

### 큐

- 한 쪽으로 데이터를 삽입하고, 다른 한 쪽으로 데이터를 삭제할 수 있는 자료구조.
- 선입선출(FIFO(First In First Out)) 자료구조라고 이야기하기도 한다.
- 각종 버퍼로 활용된다.
- 큐의 종류:

  - 선형 큐(Linear Queue)
    - 기본적인 큐
  - 원형 큐(Circular Queue)
    - 데이터를 삽입하는 쪽과 삭제하는 쪽 을 하나로 연결해 원형으로 사용하는 큐
  - 덱(Deque, ArrayDeque(Java))
    - 양쪽 모두에서 삽입과 삭제가 모두 가능한 큐
  - 우선순위 큐(Priority Queue)
    - 선입선출이 아닌 우선순위가 높은 데이터가 먼저 나오는 큐.
    - 힙(heap)을 기반으로 구현된다.

- **주요 연산 및 시간 복잡도(Java ,LinkedList 기준)**

  - Enqueue(offer(), add()): 큐의 뒤에 요소 추가, O(1)
  - Dequeue(poll(), remove()): 큐의 앞에서 요소 제거 및 반환, O(1)

## 4. 해시 테이블

- 키, 값의 대응으로 이루어진 테이블 형태의 자료구조.
- 키는 해시 테이블에 대한 입력, 값은 키를 통해 얻고자 하는 데이터.
- 값들은 배열의 형태로 버킷(bucket)에 저장되어 있으며, 해시 함수를 통해 키를 인덱스로 변환시켜 값을 얻는다.

- 해시 함수

  - 임의의 길이를 가진 데이터를 고정된 길이의 데이터로 변환하는 단방향 함수
  - MD5, SHA-1, SHA-256, SHA-512, SHA3, HMAC 등이 있다.

- **해시 테이블 연산의 시간 복잡도**

  - 접근(Access): O(1) (평균)
  - 검색(Search): O(1) (평균)
  - 삽입(Insert): O(1) (평균)
  - 삭제(Delete): O(1) (평균)
  - 최악의 경우: O(n)

- **해시 충돌**
  - 서로 다른 키에 대해 같은 해시 값에 대응되는 상황
  - 해결 방법
    - 체이닝(Chaining): 충돌이 발생한 데이터를 연결 리스트로 추가 (Java에서 사용)
    - 개방 주소법(Open Addressing): 충돌이 발생했을 때 다른 버킷을 찾아 저장 (Python, JS, Go 등)
      - 선형 조사법(Linear Probing): 충돌 발생 시 순차적으로 다음 버킷 확인
      - 이차 조사법(Quadratic Probing): 충돌 발생 시 제곱수만큼 떨어진 버킷 확인
      - 이중 해싱(Double Hashing): 처음과 다른 두 번째 해시 함수를 사용하여 다음 위치 결정

## 5. 트리

- 계층적 구조를 표현하기 위한 자료구조
- 노드와 간선(링크)으로 이루어져 있으며 간선으로 연결된 노드는 상하 관계를 형성한다.

- 트리 용어 모음

  - 노드(Node): 데이터를 저장하는 기본 요소
  - 간선(Edge): 노드를 연결하는 선
  - 부모 노드(Parent Node): 특정 노드의 상위 노드
  - 자식 노드(Child Node): 특정 노드의 하위 노드
  - 형제 노드(Sibling Node): 같은 부모를 공유하는 노드
  - 조상 노드(Ancestor Node): 특정 노드의 상위 노드들
  - 루트 노드(Root Node): 트리의 최상위 노드
  - 리프 노드(Leaf Node): 자식이 없는 노드
  - 차수(Degree): 노드가 가진 자식 노드의 수
  - 레벨(Level): 루트에서 특정 노드까지의 경로 길이
  - 높이(Height): 루트에서 가장 먼 리프까지의 경로 길이
  - 서브트리(Subtree): 트리 내의 부분 트리

- **트리의 순회**

  - 전위 순회(Preorder): 루트 노드 → 왼쪽 서브트리 → 오른쪽 서브트리
  - 중위 순회(Inorder): 왼쪽 서브트리 → 루트 노드 → 오른쪽 서브트리
  - 후위 순회(Postorder): 왼쪽 서브트리 → 오른쪽 서브트리 → 루트 노드
  - 레벨 순서 순회(Level-order): 레벨 순서대로 노드를 순회 (동일 레벨에서는 왼쪽에서 오른쪽으로)

- ** 트리의 종류 **

  - 이진 트리(binary tree)

    - 자식 노드의 개수가 2개 이하인 트리

  - 종류

    - 편향된 이진 트리(Skewed Binary Tree)
      - 모든 자식 노드가 한 쪽으로 치우친 이진 트리
    - 정 이진 트리(Full Binary Tree)
      - 자식 노드의 개수가 1이 아닌 이진 트리
    - 포화 이진 트리(Perfect Binary Tree)
      - 모든 리프 노드의 레벨이 같고, 다른 모든 노드의 자식 노드가 2개씩 채워져 있는 경우
    - 완전 이진 트리(Complete Binary Tree)
      - 마지막 레벨을 제외한 모든 레벨이 2개의 자식 노드를 가지고 있으며, 마지막 레벨의 모든 노드들이 왼쪽부터 존재하는 이진트리

  - 이진 탐색 트리(BST, Binary Search Tree)

    - 특정 노드의 왼쪽 서브트리 모든 노드는 특정 노드보다 작고, 오른쪽 서브트리의 모든 노드는 특정 노드보다 큰 이진 트리

  - 힙(Heap)

    - 완전 이진 트리 기반의 종류 중 하나.
    - 최댓값과 최솟값을 빠르게 찾기 위해 사용.
    - 종류
      - 최대 힙(Max Heap): 부모 노드가 자식 노드의 값보다 큰 값으로 이루어진 이진 트리
      - 최소 힙(Min Heap): 부모 노드가 자식 노드의 값보다 작은 값으로 이루어진 이진 트리

  - 자가 균형 이진 탐색 트리(Self-balancing Binary Search Tree)

    - 트리의 높이를 차이를 최소화하여 연산 효율을 향상시키는 이진 트리
    - 종류
      - AVL 트리
        - 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1이다.
        - 어떤 시점에서 높이 차이가 1보다 커지면 회전을 통해 균형을 잡는다.
      - RB Tree
        - 노드에 색을 칠하는 규칙과 노드에 칠해진 색을 기준으로 균형을 유지하는 이진 탐색 트리
        - 모든 노드는 레드 또는 블랙 노드이다.
        - 루트 노드는 블랙 노드이다.
        - 리프 노드는 블랙 노드이다.
        - 레드 노드의 자식 노드는 블랙 노드이다.
        - 루트 노드에서 임의의 리프 노드에 이르는 경로의 블랙 노드 수는 같다.
        - 리프 노드는 실질적인 데이터가 저장되어 있지 않다.(NIL(Null Leaf))
        - Java HashMap의 트리 저장 방식에 사용된다.

  - B 트리

    - 다진 탐색 트리의 한 종류로 자식 노드를 M개 이하로 가질 수 있는 균형 트리 (이 때 'M차 B 트리'라 부른다.)

    - 각 노드는 하나 이상의 키값이 존재하고 자식 포인터를 가진다.
    - 모든 리프 노드의 깊이가 같다.

    - B+트리
      - B 트리의 변형으로, 실질적인 데이터가 리프 노드에 위치한다.
      - 리프 노드들은 연결 리스트의 형태를 띄고 있다.
      - 데이터베이스에 주로 활용된다.

## 6. 그래프

- 정점(Vertex)이라 불리는 데이터를 간선(Edge) 혹은 링크(Link)으로 연결한 형태의 자료구조
- 특정 정점에서 출발해 다시 되돌아오는 경로가 존재하는 경우 사이클(Cycle)이 존재한다 표현한다.

- 종류

  - 연결 그래프(Connected Graph)
    - 모든 정점 쌍 사이에 경로가 있는 그래프
  - 비연결 그래프(Disconnected Graph)
    - 일부 정점 사이에 경로가 없는 그래프
  - 방향 그래프(Directed Graph)
    - 간선에 방향이 있는 그래프
  - 무방향 그래프(Undirected Graph)
    - 간선에 방향이 없는 그래프
  - 가중치 그래프(Weighted Graph)
    - 간선에 가중치(비용)가 부여된 그래프
  - 서브 그래프(Subgraph, 부분 그래프)
    - 특정 그래프의 일부 정점과 간선으로 구성된 그래프

- 그래프의 표현
  - 인접 행렬(Adjacency martrix)
    - N\*N 크기의 행렬로 그래프를 표현하는 방법.
  - 인접 리스트(Adjacency List)
    - 각 정점에 연결된 정점들을 리스트로 표현하는 방법.

### 깊이 우선 탐색과 너비 우선 탐색

- 깊이 우선 탐색(DFS, Depth-First Search)

  - 그래프에서 더 이상 방문 가능한 정점이 없을 때까지 탐색하기를 반복하는 탐색 방법

    1. 시작 정점을 방문
    2. 인접한 미방문 정점이 있다면 방문
    3. 인접한 미방문 정점이 없으면 이전 정점으로 되돌아감
    4. 모든 정점을 방문할 때까지 2-3 반복

- 너비 우선 탐색(BFS, Breadth-First Search)

  - 그래프에서 같은 레벨의 정점들을 모두 탐색한 후 다음 레벨의 정점을 탐색하는 탐색 방법
    1. 시작 정점을 방문
    2. 방문한 정점과 연결된 미방문 정점을 차례로 방문
    3. 2번을 반복

### 최단 경로 알고리즘

- 다익스트라 알고리즘(Dijkstra's Algorithm)

  - 한 정점에서 다른 정점까지의 최단 경로를 구하는 알고리즘
  - 간선의 가중치가 음수가 아닐 때 사용 가능
    1. 시작 정점을 제외한 정점들을 충분히 큰 수로 초기화 후 시작 정점 방문
    2. 시작 정점으로부터 경로 상의 가중치 합과 최단 거리 테이블 상의 값을 비교하고 갱신
    3. 방문하지 않은 정점 중 최단 거리가 가장 작은 정점 방문
    4. 모든 정점을 방문할 때까지 2-3 반복
