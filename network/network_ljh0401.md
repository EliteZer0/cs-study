# 5장 네트워크

## 5. 응용 계층 - HTTP의 기초

#### DNS와 URI / URL

- 도메인 네임(Domain Name) : 호스트의 IP 주소를 대체하는 문자열

  - 루트 도메인, 최상위 도메인(TLD), 2단계 도메인(second-level domain), 3단계 도메인, .... (4, 5단계)
  - 전체 주소 도메인 네임(FQDN) : 도메인 네임을 모두 포함하는 도메인 네임
  - FQDN을 통해 호스트를 식별한다.

- 도메인 네임 시스템(DNS) : 도메인 네임을 바탕으로 호스트의 IP 주소를 관리하는 체계

  - DNS 캐시 : 네임 서버들이 기존에 응답받은 결과를 임시로 저장 (보통 TTL만큼 저장)
  - 루트 네임 서버, TLD 네임 서버 , 2단계 도메인, .... 순으로 질의

- DNS 레코드
  ![DNS 레코드](./img/record_ljh0401.png)

#### URI/URL

- 자원 : 네트워크 상의 메시지를 통해 주고받는 최종 대상

  - HTML, 이미지, Json 등
  - URI를 통해 식별

- URI : 웹 상에서 자원을 식별하기 위한 정보

  - '이름'으로 자원을 식별하는 방식(URN), '위치'를 기반으로 식별하는 방식(URL)이 있다.

- URL의 구성 요소

  - scheme

    - 자원에 접근하는 방법
    - 예시 : http, https, ftp 등

  - authority

    - 호스트를 특정할 수 있는 IP 주소나 도메인 네임
    - 예시 : www.example.com

  - path

    - 자원이 위치하고 있는 경로 ('/'로 구분된 계층적 구조)
    - 예시 : /home/images/a.png

  - query

    - URL에 대한 매개변수 (검색을 위한 추가 정보)
    - '?'로 시작되는 <키=값> 형태의 데이터, '&'를 통해 여러 쿼리 문자열 사용 가능
    - 예시 : ?location=seoul&rooms=2

  - fragment

    - 자원의 일부분을 가리키기 위한 정보
    - '#' 뒤에 위치
    - 예시 : #section-1.1.2

#### HTTP의 특징과 메시지 구조

- HTTP의 특징

  - 요청 응답 기반 프로토콜

    - 클라이언트가 요청을 보내고, 서버가 이에 대한 응답을 보내는 구조

  - 미디어 독립적 프로토콜

    - 미디어 타입(MIME 타입)에 제한없이 독립적으로 작동이 가능한 구조

  - 스테이트리스 프로토콜

    - 클라이언트 관련 상태를 유지하지 않는다. (모든 요청은 독립적인 요청으로 간주)
    - 확장성과 견고성 향상

  - 지속 연결 프로토콜

    - 1.1 이상에서 하나의 TCP 연결 상에서 여러 요청-응답을 주고받을 수 있도록 지속연결(킵 얼라이브) 가능.

- HTTP 메시지 구조(1.1 기반)

  - 요청 / 상태 라인 : 요청 메시지, 응답 메시지를 구분해주는 기준
    ![요청 / 상태](./img/request_status_ljh0401.png)
  - 필드 라인
    - HTTP 헤더 : HTTP 메시지 전송과 관련된 부가 정보이자 제어 정보.
    - 요청에는 Accept, Host 등 요청자의 부가 정보, 응답에는 Content-Type 등 응답의 부가 정보가 포함된다.
  - HTTP 메서드
    ![HTTP method](./img/HTTP_method_ljh0401.png)
    - GET : 자원을 조회한다. (본문 내용 포함)
    - HEAD : 자원을 조회한다. (본문 없이 응답 헤더만)
    - POST : 서버로 특정 작업을 처리/요청한다.
    - PUT : 덮어쓰기를 요청한다. (전체 자원을 덮어쓴다.)
    - PATCH : 부분적 수정을 요청한다. (일부분만 수정한다.)
    - DELETE : 특정 자원 삭제를 요청한다.

- HTTP 상태 코드

  - 3자리 정수로 구성된, 요청에 대한 서버 처리 결과를 알려주는 코드.
    ![status](./img/status_ljh0401.png)
    - 200번대 : 성공 상태 코드
      ![200](./img/200_ljh0401.png)
    - 300번대 : 리다이렉션 상태 코드
      ![300](./img/300_ljh0401.png)
      - 영구적 리다이렉션 : 자원이 완전히 새로운 곳으로 이동
      - 일시적 리다이렉션 : 자원의 위치가 임시로 변경
    - 400번대 : 클라이언트 에러 상태 코드
      ![400](./img/400_ljh0401.png)
    - 500번대 : 서버 에러 상태 코드
      ![500](./img/500_ljh0401.png)

- HTTP 주요 헤더

  - 요청 메시지 HTTP 헤더
    - Host : 요청을 보낼 호스트가 명시
    - User-Agent : 요청을 보낸 클라이언트의 프로그램과 관련된 정보
    - Referer : 현재 요청 직전 페이지 주소
  - 응답 메시지 HTTP 헤더
    - Server : 응답한 서버 호스트와 관련된 정보
    - Allow : 처리 가능한 HTTP 헤더 목록(HTTP 메서드) 명시
    - Location : 클라이언트에게 자원의 위치를 알려 주기 위해 사용 (보통 리다이렉션 시)
  - 모두 활용되는 HTTP 헤더
    - Date : 메시지 생성 날짜와 시각 정보
    - Content-Length : 메시지 본문 바이트 단위 크기
    - Content-Type : MIME 타입
    - Content-Language : 메시지 본문에 사용된 자연어, 언어-국가
      ![language](./img/language_ljh0401.png)
    - Content-Encoding : 메시지 본문 압축, 변환 방식
    - Connection : 연결 방식 명시 (keep-alive, close)

## 6. 응용 계층 - HTTP의 응용

#### 쿠키

- 쿠키

  - HTTP의 스테이트리스 프로토콜을 보완하기 위한 대표적인 수단으로 클라이언트에 저장되는 <이름, 값> 쌍 형태의 데이터
  - 서버의 Set-Cookie 헤더로 저장하고, Cookie 헤더로 응답에 담는다.
  - HTTPS로만 송수신하는 Secure, 자바스크립트를 통한 접근을 제한하는 HttpOnly로 보안을 강화할 수 있다.

- 웹 스토리지
  - 로컬 스토리지 : 별도로 삭제하지 않는 한 영구적으로 저장이 가능한 정보
  - 세션 스토리지 세션이 유지되는(브라우저가 열려 있는) 동안 유지되는 정보
  - 쿠키는 서버로 자동 전송되지만, 웹 스토리지의 정보는 서버로 자동 전송되지 않는다.

#### 캐시

- HTTP 캐시

  - 서버에서 받은 응답(자원)을 임시 저장해놓고, 같은 요청이 반복될 때 저장된 자원을 재활용
  - 지정된 유효 기간동안 자원을 임시 저장하여 활용한다.

  - 캐시 신선도(Cache Freshness)
    - 캐시된 사본 데이터가 서버의 원본 데이터와 얼마나 유사한지의 정도
    - 유효 기간 만료 시 서버에 변경 여부를 확인한다.

- If-Modified-Since 헤더

  - 자원 변경 여부를 파악하기 위한 헤더
  - 자원이 변경되었을 경우 200 응답과 함께 새로운 자원 반환
  - 변경되지 않을 경우 304를 통해 변경되지 않음을 알림
  - 삭제되었을 경우 404를 통해 자원이 존재하지 않음을 알림

- If-None-Match 헤더
  - Etag(Entity Tag)를 통해 자원의 버전을 식별할 경우 If-None-Match 헤더로 자원 변경 여부 파악 가능
  - 자원이 변경되었을 경우 200 응답과 함께 새로운 자원 반환
  - 변경되지 않을 경우 304를 통해 변경되지 않음을 알림
  - 삭제되었을 경우 404를 통해 자원이 존재하지 않음을 알림

#### 콘텐츠 협상

- 콘텐츠 협상

  - 사용자(클라이언트)가 가장 적합하다는(선호하는) 표현으로 자원을 제공하는 기술
  - 콘텐츠 협상 헤더

    - Accept : 선호하는 MIME 타입
    - Accept-Language : 선호하는 언어
    - Accept-Encoding : 선호하는 인코딩 방식

  - 우선순위 지정 방식
    - q(Quality Value)로 우선순위를 표현 (0 ~ 1까지의 값(생략 시 1))
    - 1일 때 가장 큰 선호도

#### 보안: SSL/TLS와 HTTPS

- HTTPS

  - HTTP + SSL/TLS 프로토콜 동작 추가
  - 현재 TLS 1.3 프로토콜 널리 사용

- TLS 1.3

  - HTTPS 메시지 송수신 : 기본적인 HTTP 메시지 송수신에 TLS 핸드셰이크 추가

    - TCP 쓰리 웨이 핸드셰이크
    - TLS 핸드 셰이크
      - 암호화 통신을 위한 키 생성/교환, 인증서 송수신 및 검증
    - 메시지 송수신

  - TLS 핸드셰이크
    ![TLS](./img/TLS_ljh0401.png)

    - 암호화 통신을 위한 키 교환

      - 클라이언트가 사용 가능한 암호화 알고리즘과 해시 함수를 ClientHello 메시지에 포함하여 전송
      - 메시지에 담은 암호화 알고리즘, 해시 함수에 대한 정보를 암호 스위트(cipher suite)라고 한다.

    - 인증서를 통한 인증

      - 제 3의 인증 기관(CA)가 인증한 인증서를 통해 믿을 수 있는 서버임을 증명
      - Certificate, CertificateVerify 메시지를 통해 인증서와 인증서 내용이 올바른지 검증
      - 해당 과정을 통해 통신하는 상대방이 원하는 상대가 맞음을 인증

## 7. 프록시와 안정적인 트래픽

#### 오리진 서버와 중간 서버: 포워드 프록시와 리버스 프록시

- 오리진 서버

  - 클라이언트가 최종적으로 메시지를 주고받는 서버
  - 오리진 서버 앞에는 여러 중간 서버가 있을 수 있다

- 중간 서버

  - 클라이언트와 오리진 서버 사이에 위치하여 중계 역할을 수행
  - 크게 프록시 서버와 게이트웨이가 있다.
    - 프록시 서버
      - 클라이언트가 선택한 메시지 전달의 대리자.
      - 클라이언트의 심부름꾼 또는 대리인
      - 주로 캐싱, 암호화 및 접근 제한 등의 기능을 제공한다.
    - 게이트웨이
      - 오리진 서버를 향하는 메시지를 먼저 받아 점검하는 문지기.
      - 오리진 서버의 문지기이자 경비
      - 주로 캐싱, 로드 밸런서로 동작한다.

#### 고가용성: 로드 밸런싱과 스케일링

- 가용성
  ![availability](./img/availability_ljh0401.png)

  - 주어진 특정 기능을 실제로 수행할 수 있는 시간의 비율
  - 시스템의 안정성을 평가하기 위한 지표
  - 업타임 / (업타임 + 다운타임)
    - 업타임 : 정상적인 사용 시간
    - 다운타임 : 모종의 이유로 정상적인 사용이 불가능한 시간
  - 가용성을 위해 보통 결함 감내(fault tolerance) 설계로 문제가 발생하더라도 계속 기능하도록 설계한다.

- 로드 밸런싱

  - 가용성을 보장하기 위해 트래픽의 고른 분배를 위해 사용되는 기술
  - 로드 밸런서에 의해 수행되며, L4 스위치, L7 스위치 혹은 Nginx 와 같은 소프트웨어를 활용한다.
  - 사용 알고리즘
    - 라운드 로빈 : 단순히 서버를 돌아가며 순차적 부하 전달
    - 최소 연결 : 연결이 적은 서버부터 우선적 부하 전달
    - 가중치 기반 : 서버가 서로 다른 성능을 가질 경우 가중치가 높은 서버에 더 많은 부하 전달

- 스케일링
  - 스케일 업
    - 기존 서버를 더 좋은 장비로 교체(수직적 확장)
    - 단순하지만, 유연하지 않다. (지속적으로 더 비싼 장비 필요, 서버 제한 시 가용성 저하)
  - 스케일 아웃
    - 기존 서버 수를 늘리는 방식(수평적 확장)
    - 유연적인 확장 가능, 로드 밸런서를 통한 가용성 확보

#### Nginx로 알아보는 로드 밸런싱

- Nginx

  - 포워드 프록시, 리버스 프록시 기능 제공.
  - 설정 시 콘텐츠 캐싱, 보안 접근 제어, 로드 밸런싱 등도 가능.

- 업스트림 : 상위 서버로 데이터를 보내는 방향
- 다운스트림 : 상위 서버에서 클라이언트로 데이터를 보내는 방향
- 인바운드 : 네트워크 외부에서 내부로 들어오는 트래픽
- 아웃바운드 : 내부 네트워크에서 외부로 나가는 트래픽
