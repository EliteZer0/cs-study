# 🌐 네트워크 - HTTP의 기초

## 📡 DNS와 URI/URL

### 🏷️ 도메인 네임과 DNS

- **도메인 네임**: IP 주소에 대응하는 문자열 형태의 호스트 식별 정보
  - 예: `www.example.com`, `developers.naver.com`
  - IP 주소보다 기억하기 쉽고, IP 주소가 바뀌어도 도메인 네임으로 접근 가능

- **DNS (Domain Name System)**: 도메인 네임과 IP 주소를 관리하는 시스템
  - **네임 서버**: 도메인 네임과 IP 주소의 대응 관계를 저장하는 서버
  - **리졸빙(Resolving)**: 도메인 네임으로부터 IP 주소를 알아내는 과정

### 🌳 도메인 네임의 계층 구조

```
www.example.com.
│    │      │   └── 루트 도메인 (생략됨)
│    │      └── 최상위 도메인 (TLD)
│    └── 2단계 도메인
└── 3단계 도메인 (서브 도메인)
```

- **FQDN (Fully Qualified Domain Name)**: 모든 계층을 포함한 완전한 도메인 네임

### 🔍 DNS 질의 과정

1. **로컬 DNS 서버**: 클라이언트가 가장 먼저 질의하는 서버
   - ISP에서 자동 할당하거나 공개 DNS 서버 사용 (8.8.8.8, 1.1.1.1)
2. **루트 DNS 서버**: 최상위 도메인 정보 제공
3. **TLD DNS 서버**: 최상위 도메인(.com, .kr 등) 관리
4. **권한 있는 DNS 서버**: 최종 IP 주소 제공

### 💾 DNS 캐시
- **목적**: 네트워크 트래픽 감소, 응답 시간 단축
- **TTL (Time To Live)**: 캐시될 수 있는 시간

### 📝 DNS 레코드 타입

| 타입 | 설명 |
|------|------|
| A | 호스트의 도메인 네임과 IPv4 주소 대응 |
| AAAA | 호스트의 도메인 네임과 IPv6 주소 대응 |
| CNAME | 호스트 네임에 대한 별칭 지정 |
| NS | 특정 호스트의 IP 주소를 찾을 수 있는 네임 서버 |
| MX | 해당 도메인과 연동된 메일 서버 |

### 🔗 URI와 URL

- **URI (Uniform Resource Identifier)**: 웹 상의 자원을 식별하기 위한 정보
- **URL (Uniform Resource Locator)**: 위치 기반으로 자원을 식별하는 방식
- **URN (Uniform Resource Name)**: 이름 기반으로 자원을 식별하는 방식

#### URL 구조
```
https://www.example.com:8042/over/there?name=ferret#nose
└─┬─┘ └─────┬─────────┘└┬┘└────┬────┘└────┬────┘└┬┘
scheme    authority    port  path      query   fragment
```

- **Scheme**: 자원에 접근하는 방법 (프로토콜)
- **Authority**: 호스트 정보 (IP 주소 또는 도메인 네임)
- **Path**: 자원이 위치한 경로
- **Query**: URL에 대한 매개변수 (`?key=value&key2=value2`)
- **Fragment**: 자원의 일부분을 가리키는 정보 (`#section`)

---

## 🌍 HTTP의 특징과 메시지 구조

### ⚡ HTTP의 주요 특징

1. **요청-응답 기반 프로토콜**
   - 클라이언트가 요청 메시지 전송
   - 서버가 응답 메시지 전송

2. **미디어 독립적 프로토콜**
   - 다양한 미디어 타입 지원 (HTML, JSON, 이미지, 동영상 등)
   - 미디어 타입은 `타입/서브타입` 형식 (예: `text/html`, `application/json`)

3. **스테이트리스 프로토콜**
   - 서버가 클라이언트의 상태를 기억하지 않음
   - 모든 요청은 독립적으로 처리
   - 확장성과 견고성 향상

4. **지속 연결 프로토콜**
   - HTTP 1.1부터 지원
   - 하나의 TCP 연결로 여러 요청-응답 처리 가능

### 📊 미디어 타입 예시

| 타입 | 서브타입 | 설명 |
|------|----------|------|
| text | text/plain | 평문 텍스트 |
| text | text/html | HTML 문서 |
| text | text/css | CSS 문서 |
| image | image/png | PNG 이미지 |
| image | image/jpeg | JPEG 이미지 |
| video | video/mp4 | MP4 비디오 |
| audio | audio/wav | WAV 오디오 |
| application | application/json | JSON 데이터 |
| application | application/pdf | PDF 문서 |
| multipart | multipart/form-data | HTML 폼 데이터 |

#### 추가 표기 방법
- **와일드카드**: `text/*` (모든 text 타입), `*/*` (모든 타입)
- **매개변수**: `text/html;charset=UTF-8`

### 📊 HTTP 버전별 특징

| 버전 | 주요 특징 |
|------|-----------|
| HTTP 1.1 | 지속 연결 지원, 평문 메시지 |
| HTTP 2.0 | 바이너리 데이터, 헤더 압축, 서버 푸시, 멀티플렉싱 |
| HTTP 3.0 | QUIC(UDP 기반) 프로토콜 사용, 속도 개선 |

#### HTTP 2.0의 HOL 블로킹 해결
- **문제**: 첫 번째 패킷 지연이 나머지 패킷 처리도 지연시킴
- **해결**: 멀티플렉싱을 통한 독립적인 스트림 처리

### 📄 HTTP 메시지 구조

```
시작 라인 (요청 라인 또는 상태 라인)
헤더 필드 1: 값
헤더 필드 2: 값
                    ← 빈 줄
메시지 본문 (선택적)
```

#### 요청 메시지
```
GET /example HTTP/1.1
Host: www.example.com
Accept: text/html
```

#### 응답 메시지
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 648

<!DOCTYPE html>
<html>...
```

---

## 🔧 HTTP 메서드와 상태 코드

### 🎯 주요 HTTP 메서드

| 메서드 | 용도 | 설명 |
|--------|------|------|
| GET | 조회 | 자원의 표현을 조회 |
| HEAD | 헤더 조회 | GET과 동일하나 헤더만 응답 |
| POST | 처리/생성 | 서버가 특정 작업을 처리하도록 요청 |
| PUT | 대체 | 자원을 완전히 대체 (덮어쓰기) |
| PATCH | 부분 수정 | 자원의 일부분만 수정 |
| DELETE | 삭제 | 자원을 삭제 |

### 📈 HTTP 상태 코드

#### 2xx: 성공
- **200 OK**: 요청 성공
- **201 Created**: 새로운 자원 생성 성공
- **204 No Content**: 성공했지만 응답 본문 없음

#### 3xx: 리다이렉션
- **301 Moved Permanently**: 영구적 리다이렉션 (메서드 변경 가능)
- **308 Permanent Redirect**: 영구적 리다이렉션 (메서드 유지)
- **302 Found**: 일시적 리다이렉션 (메서드 변경 가능)
- **303 See Other**: 일시적 리다이렉션 (GET으로 변경)
- **307 Temporary Redirect**: 일시적 리다이렉션 (메서드 유지)
- **304 Not Modified**: 캐시된 자원 사용 가능

#### 인증과 권한의 차이
- **401 Unauthorized**: **인증(Authentication)** 필요 - "누구인지 증명"
- **403 Forbidden**: **권한(Authorization)** 없음 - "허용된 작업인지 확인"

#### 4xx: 클라이언트 오류
- **400 Bad Request**: 잘못된 요청
- **401 Unauthorized**: 인증 필요
- **403 Forbidden**: 권한 없음
- **404 Not Found**: 자원을 찾을 수 없음

#### 5xx: 서버 오류
- **500 Internal Server Error**: 서버 내부 오류
- **502 Bad Gateway**: 중간 서버 통신 오류

---

## 📋 주요 HTTP 헤더

### 📨 요청 헤더

- **Host**: 요청을 보낼 호스트
- **User-Agent**: 클라이언트 프로그램 정보 (브라우저, OS 등)
- **Referer**: 요청을 보낼 때 머무르던 URL
- **Accept**: 선호하는 미디어 타입
- **Accept-Language**: 선호하는 언어
- **Accept-Encoding**: 선호하는 인코딩 방식

### 📤 응답 헤더

- **Server**: 서버 정보
- **Allow**: 지원하는 HTTP 메서드 목록
- **Location**: 자원의 위치 (리다이렉션, 생성된 자원)

### 🔄 공통 헤더

- **Date**: 메시지 생성 날짜와 시각
- **Content-Type**: 메시지 본문의 미디어 타입
- **Content-Length**: 메시지 본문의 바이트 크기
- **Content-Language**: 메시지 본문의 자연어
- **Content-Encoding**: 메시지 본문의 압축/변환 방식
- **Connection**: 연결 방식 (`keep-alive`, `close`)

---

## 🍪 HTTP 응용 기술

### 💾 웹 스토리지

#### 쿠키 vs 웹 스토리지
| 구분 | 쿠키 | 웹 스토리지 |
|------|------|-------------|
| 서버 전송 | 자동 전송 | 전송 안됨 |
| 저장 용량 | 작음 (4KB) | 큼 (5MB+) |
| 종류 | - | 로컬/세션 스토리지 |

#### 웹 스토리지 종류
- **로컬 스토리지**: 명시적 삭제 전까지 영구 저장
- **세션 스토리지**: 브라우저 세션 동안만 유지

### 🍪 쿠키 (Cookie)

- **목적**: HTTP의 스테이트리스 특성 보완
- **구조**: `<이름=값>` 쌍 형태
- **전송**: 
  - 서버 → 클라이언트: `Set-Cookie` 헤더
  - 클라이언트 → 서버: `Cookie` 헤더

#### 쿠키 속성
- **Domain**: 쿠키가 전송될 도메인 제한
- **Path**: 쿠키가 전송될 경로 제한
- **Expires/Max-Age**: 만료 시간 설정
- **Secure**: HTTPS에서만 전송
- **HttpOnly**: 자바스크립트 접근 제한

### 📦 캐시 (Cache)

- **목적**: 응답 지연 방지, 대역폭 절약
- **종류**:
  - 개인 캐시 (Private Cache): 클라이언트에 저장
  - 공용 캐시 (Public Cache): 중간 서버에 저장

#### 캐시 신선도 (Freshness)
- **신선한 캐시**: 원본 데이터와 일치하는 캐시
- **stale 캐시**: 유효기간이 만료된 캐시

#### 캐시 제어 헤더
- **Expires**: 캐시 만료 날짜
- **Cache-Control**: 캐시 정책 (`max-age`, `no-cache` 등)
- **Last-Modified**: 자원의 마지막 수정 시간
- **ETag**: 자원의 버전 식별자

#### 캐시 검증
- **If-Modified-Since**: 날짜 기반 조건부 요청
- **If-None-Match**: ETag 기반 조건부 요청
- **304 Not Modified**: 캐시 사용 가능 응답

#### 캐시 검증 시나리오
1. **자원 변경됨**: 200 OK + 새로운 자원
2. **자원 변경 안됨**: 304 Not Modified (본문 없음)
3. **자원 삭제됨**: 404 Not Found

### 🤝 콘텐츠 협상 (Content Negotiation)

- **목적**: 클라이언트가 선호하는 자원의 표현 제공
- **협상 헤더**:
  - `Accept`: 미디어 타입 협상
  - `Accept-Language`: 언어 협상
  - `Accept-Encoding`: 인코딩 협상
- **품질 값(q)**: 선호도 표현 (0~1, 기본값 1)

### 🔐 보안: SSL/TLS와 HTTPS

#### HTTPS 연결 과정
1. **TCP 3-way Handshake**
2. **TLS Handshake**
   - ClientHello: 지원 암호화 알고리즘 제시
   - ServerHello: 사용할 암호화 알고리즘 선택
   - Certificate: 인증서 전송
   - 암호화 키 교환 및 검증
3. **암호화된 메시지 송수신**

#### TLS 핸드셰이크 주요 메시지
1. **ClientHello**: 클라이언트가 지원하는 암호화 알고리즘 제시
2. **ServerHello**: 서버가 사용할 암호화 알고리즘 선택
3. **Certificate**: 서버 인증서 전송
4. **CertificateVerify**: 인증서 검증
5. **Finished**: 핸드셰이크 완료

#### 암호 스위트 (Cipher Suite)
```
TLS_AES_128_GCM_SHA256
TLS_AES_256_GCM_SHA384
TLS_CHACHA20_POLY1305_SHA256
```

#### 인증서 (Certificate)
- **목적**: 통신 상대방의 신원 보장
- **CA (Certificate Authority)**: 인증서 발급 및 검증 기관
- **구성**: 도메인 정보, 공개키, 디지털 서명 등

---

## ⚖️ 프록시와 안정적인 트래픽 관리

### 🔄 프록시 종류

#### 포워드 프록시
- **위치**: 클라이언트와 가까이
- **역할**: 클라이언트의 대리인
- **기능**: 캐시, 접근 제한, 익명화

#### 리버스 프록시 (게이트웨이)
- **위치**: 서버와 가까이
- **역할**: 서버의 대리인
- **기능**: 로드 밸런싱, 캐시, 보안

### 📊 고가용성과 확장성

#### 오리진 서버 vs 중간 서버
- **오리진 서버**: 자원을 생성하고 권한 있는 응답을 보내는 최종 서버
- **중간 서버**: 클라이언트와 오리진 서버 사이에 위치하는 서버들

#### 결함 감내 (Fault Tolerance)
- **목적**: 문제 발생 시에도 계속 기능할 수 있는 능력
- **방법**: 다중화, 페일오버, 로드 밸런싱

#### 가용성 (Availability)
```
가용성 = 업타임 / (업타임 + 다운타임)
```

| 가용성 | 별칭 | 연간 다운타임 |
|--------|------|---------------|
| 99% | 투 나인스 | 3.65일 |
| 99.9% | 쓰리 나인스 | 8.77시간 |
| 99.99% | 포 나인스 | 52.56분 |
| 99.999% | 파이브 나인스 | 5.26분 |

#### 헬스 체크와 하트비트
- **헬스 체크**: 서버 상태를 주기적으로 검사 (로드 밸런서가 수행)
- **하트비트**: 서버 간 주기적 메시지 교환으로 상태 확인

#### 로드 밸런싱 알고리즘
- **라운드 로빈**: 서버를 순환하며 요청 분배
- **최소 연결**: 연결 수가 가장 적은 서버로 분배
- **가중치 기반**: 서버 성능에 따른 가중치 적용
- **IP 해시**: IP 주소 기반 해시로 서버 선택
- **랜덤**: 무작위 서버 선택

#### 스케일링 방식
- **스케일 업 (Scale Up)**: 더 좋은 사양의 장비로 교체
- **스케일 아웃 (Scale Out)**: 여러 장비를 추가하여 확장
- **오토 스케일링**: 필요에 따라 자동으로 확장/축소

### 🌐 웹 서버 vs 웹 애플리케이션 서버

| 구분 | 웹 서버 | 웹 애플리케이션 서버 (WAS) |
|------|---------|---------------------------|
| 처리 대상 | 정적 콘텐츠 | 동적 콘텐츠 |
| 예시 | HTML, 이미지, CSS 파일 | 데이터베이스 조회 결과, 계산된 값 |
| 대표 제품 | Nginx, Apache HTTP Server | Tomcat, JBoss, WebSphere |

---

## 🛠️ 실습: Nginx로 로드 밸런싱

### 기본 설정 예시

```nginx
# 서버 그룹 정의
upstream backend {
    server 10.10.10.2:80 weight=1;
    server 10.10.10.3:80 weight=2;
    server 10.10.10.4:80 backup;
}

# 서버 설정
server {
    listen 80;
    server_name localhost;
    
    location / {
        proxy_pass http://backend;
    }
}
```

### 로드 밸런싱 알고리즘 설정

```nginx
upstream backend {
    least_conn;  # 또는 random, ip_hash
    server 10.10.10.2:80;
    server 10.10.10.3:80;
}
```

---

## 📚 추가 개념

### 🔌 소켓 프로그래밍
- **소켓**: 네트워크 통신의 엔드포인트
- **특징**: 파일과 유사하게 읽기/쓰기 가능
- **시스템 콜**: `socket()`, `bind()`, `listen()`, `accept()`, `send()`, `recv()`

### 📈 트래픽 용어
- **업스트림**: 클라이언트에서 서버로 향하는 방향
- **다운스트림**: 서버에서 클라이언트로 향하는 방향
- **인바운드**: 외부에서 내부로 들어오는 트래픽
- **아웃바운드**: 내부에서 외부로 나가는 트래픽

### 🔍 모니터링과 관리
- **헬스 체크**: 서버 상태를 주기적으로 확인
- **하트비트**: 서버 간 주기적 메시지 교환으로 상태 확인
- **페일오버**: 장애 발생 시 예비 시스템으로 자동 전환

### 💡 기타 중요 개념

#### Base64 인코딩
- **목적**: 바이너리 데이터를 ASCII 문자로 표현
- **용도**: 이메일 첨부파일, 웹에서 이미지 데이터 전송
- **원리**: 6비트를 하나의 문자로 변환 (2^6 = 64개 문자 사용)

#### 부동소수점 표현의 한계
```python
print(0.1 + 0.2)  # 0.30000000000000004
print(0.1 + 0.2 == 0.3)  # False
```
- **원인**: 10진 소수를 2진 부동소수점으로 정확히 표현 불가능
- **해결**: 정수 연산 후 나누기, 또는 Decimal 라이브러리 사용